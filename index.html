<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="bai">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="bai">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="bai">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>bai</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
    <a href="https://github.com/baiyunshenghaishang"><img style="position:absolute;top:0;right:0" width="149" height="149" src="https://github.blog/wp-content/uploads/2008/12/forkme_right_gray_6d6d6d.png?resize=149%2C149" class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">bai</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/23/basis/lexical/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhen Huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/23/basis/lexical/" itemprop="url">词法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-23T19:02:02+08:00">
                2019-05-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>js 词法简介</p>
<h3 id="什么是词法"><a href="#什么是词法" class="headerlink" title="什么是词法"></a>什么是词法</h3><p>从浏览器执行的角度看，js 文件最先是通过网络从服务器上获取的，得到是一段二进制数据，然后浏览器根据对应的编码将这段二进制数据转换为字符串。<br>再将字符串拆分为有意义的词，一般称之为 token。token 是语言的最小语义单元。<br>词法规定了语言的 token 种类。</p>
<h3 id="词的分类"><a href="#词的分类" class="headerlink" title="词的分类"></a>词的分类</h3><p>js 中的词包括以下几种</p>
<ol>
<li>空白符</li>
<li>换行符</li>
<li>注释</li>
<li>标识符名称</li>
<li>符号</li>
<li>数字字面量</li>
<li>字符串字面量</li>
<li>字符串模板</li>
<li>正则表达式字面量</li>
</ol>
<p>下面分别讲述这几种不同的词</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>注释对于词法而言一般是无意义的，但是对 js 的语法的自动分号补全规则有影响。因为包含换行符的注释会被认为包含换行符，所以注释也是一种有效的词法。<br>除此之外，注释并没有特别的意义。</p>
<h3 id="空白符"><a href="#空白符" class="headerlink" title="空白符"></a>空白符</h3><p>js 支持 unicode 中的所有空白符，种类很多，下面介绍几种常用的</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">HT</td>
<td style="text-align:center">U+0009, \t 即常见的 tab 缩进</td>
</tr>
<tr>
<td style="text-align:center">VT</td>
<td style="text-align:center">\v 垂直缩进，比较少见</td>
</tr>
<tr>
<td style="text-align:center">FF</td>
<td style="text-align:center">分页符 \f</td>
</tr>
<tr>
<td style="text-align:center">SP</td>
<td style="text-align:center">U+0020, 常见的空格</td>
</tr>
<tr>
<td style="text-align:center">NBSP</td>
<td style="text-align:center">U+00a0, 非断行空格，html 中的<code>&amp;nbsp;</code>就是它</td>
</tr>
<tr>
<td style="text-align:center">ZWNBSP</td>
<td style="text-align:center">BOM，零宽非断行空格，常用于文件头部表示 utf 的编码方式</td>
</tr>
<tr>
<td style="text-align:center">ZWSP</td>
<td style="text-align:center">零宽空格</td>
</tr>
</tbody>
</table>
<p>其它空格参见<a href="https://zh.wikipedia.org/wiki/%E7%A9%BA%E6%A0%BC" target="_blank" rel="noopener">wiki-空格</a></p>
<p>一般而言，空格符对 js 的执行是没有影响的。但是字符串中可以包含零宽空格，会改变字符串的长度，也可以有一些有意思的应用。<br><a href="https://github.com/baiyunshenghaishang/zero-width-space" target="_blank" rel="noopener">零宽空格的一种应用</a></p>
<h3 id="换行符"><a href="#换行符" class="headerlink" title="换行符"></a>换行符</h3><p>不同于空格符，js 中只提供了 4 种换行符。<br>换行符对语法的影响也只存在于分号自动补全规则。</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">LF</td>
<td style="text-align:center">通常意义的换行符，\n</td>
</tr>
<tr>
<td style="text-align:center">CR</td>
<td style="text-align:center">回车，\r</td>
</tr>
<tr>
<td style="text-align:center">LS</td>
<td style="text-align:center">unicode 中的行分隔符</td>
</tr>
<tr>
<td style="text-align:center">PS</td>
<td style="text-align:center">unicode 中的段落分隔符</td>
</tr>
</tbody>
</table>
<h3 id="标识符名称"><a href="#标识符名称" class="headerlink" title="标识符名称"></a>标识符名称</h3><p>标识符名称包含变量名、关键字、保留字、true/false 和 null<br>其中变量名可以以 美元符号\$、下划线_或字母开始，还可以包含数字</p>
<p>关键字和保留字就不列举了<br>可以参见<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Lexical_grammar" target="_blank" rel="noopener">MDN 词法</a></p>
<h3 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h3><p>js 中的所有符号如下<br><code>{ ( ) [ ] . ... ; , &lt; &gt; &lt;= &gt;= == != === !== + - * % ** ++ -- &lt;&lt; &gt;&gt; &gt;&gt;&gt; &amp; | ^ ! ~ &amp;&amp; || ? : = += -= *= %= **= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;= &amp;= |= ^= =&gt; / /= }</code></p>
<h3 id="数字字面量"><a href="#数字字面量" class="headerlink" title="数字字面量"></a>数字字面量</h3><p>数字字面量包含 2 进制、8 进制、10 进制、16 进制 4 种形式<br>2 进制以 0b/0B 开头，数字不能超过 1，如<code>0b011101</code><br>8 进制以 0o/0O 开头，数字不能超过 7，如<code>0o12345667</code><br>10 进制就是我们常见的数字<br>16 进制以 0x/0X 开头，包含<code>0-9,A-F</code>，如<code>0xA32E</code>，也可以使用小写字母</p>
<p>其中只有10进制可以包含小数和使用科学计数法。</p>
<p>小数点前面和后面的数字都可以省略，如<code>10.</code>,<code>.03</code>都是有效的数字，但是不能同时省略。</p>
<p>小数点的优先级比属性获取要高，所以<code>10.toString</code>中的<code>.</code>会被认为是小数点，从而报词法错误。正确的使用方式应该是<code>10..toString</code></p>
<p>10进制的数字还可以使用科学计数法表示，如<code>3e6</code><br>也可以使用大写E,e之前可以使用小数，e之后只能使用整数，可以是负数，如<code>10.23E-3</code></p>
<h3 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h3><p>字符串可以使用单引号，也可以使用双引号。单引号字符串中双引号必须转义，双引号字符串中单引号必须转义，除此之外没有区别。<br>字符串除了字面量的表示，还支持 unicode 表示。</p>
<ol>
<li>使用 <code>\uXXXX</code>，表示基本平面的字符</li>
<li>使用<code>\u{XXXXXX}</code>表示</li>
</ol>
<p>字符串的转义<br>关于字符串的转义，包含两部分含义，</p>
<ol>
<li>有些字符在字符串中必须被转义，比如 \</li>
<li>有些字符连在一起之后表示另外一个字符的意思，比如\n</li>
</ol>
<p>字符串中必须被转义的字符只有<code>\</code>和换行符，因为换行符是没法在字符串中直接被表示的，空白符可以。</p>
<p>包含特殊意义的字符则包括以下这些<br><code>\&#39; \&quot; \\ \b \f \t \v \n \r</code><br>其中 <code>\b</code>表示退格符，删除前一个字符，其它的前面都已经讲到</p>
<p>还有几种包含特殊意义的组合<br>\数字 八进制表示的整数，表示一个字符，数字是unicode编码的8进制表示,如z是\172，最大255<br>\xXX 16进制表示的数字，表示一个字符，数字是unicode编码的16进制表示，最大255</p>
<p>\uXXXX 16进制表示的数字,表示一个unicode基本平面的字符<br>\u{XXXXXX} 16进制表示的数字，表示一个unicode字符</p>
<p>除此之外, \和其它字符组合都是字符本身。</p>
<h3 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h3><p>字符串模板和字符串基本类似。转义规则稍有不同，字符串模板中换行符<code>\n</code>是可以通过换行直接表示的，单双引号也可以直接使用。</p>
<h3 id="正则表达式字面量"><a href="#正则表达式字面量" class="headerlink" title="正则表达式字面量"></a>正则表达式字面量</h3><p>正则表达式比较复杂，会单独写一篇博客。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/22/basis/import_export/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhen Huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/22/basis/import_export/" itemprop="url">import/export</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-22T19:20:39+08:00">
                2019-05-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="export-的基本语法"><a href="#export-的基本语法" class="headerlink" title="export 的基本语法"></a>export 的基本语法</h3><p>export 用于导出模块中的变量。</p>
<p>export 的基本语法有以下几种</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接导出变量或声明</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> a = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出已经声明的变量或声明</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">3</span></span><br><span class="line"><span class="keyword">export</span> b</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将声明的变量或声明以其它变量名导出</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span></span><br><span class="line"><span class="keyword">export</span> &#123;c <span class="keyword">as</span> d&#125;</span><br></pre></td></tr></table></figure>
<p><code>export default</code> 表示默认导出。本质上讲，其实就是输出一个叫做 default 的变量,然后在导入的时候可以取任意名</p>
<p>导出的本质是在外部用一个变量名引用内部的变量，所以必须指定外部引用的变量名。所以在 export default 除了导出变量外，还可以直接导出字面量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>因为<code>export default</code>本质上是导出一个叫做 default 的变量，所以一个模块中只能使用一次 <code>export default</code></p>
<h3 id="import-的基本语法"><a href="#import-的基本语法" class="headerlink" title="import 的基本语法"></a>import 的基本语法</h3><p>import 用于导入模块中导出的变量<br>import 的几种语法都是对应 export 的语法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export的对应导出形式</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> a = <span class="number">3</span></span><br><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">'XX'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// export导出其他变量名的导出形式</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="number">4</span></span><br><span class="line"><span class="keyword">export</span> &#123; c <span class="keyword">as</span> d &#125;</span><br><span class="line"><span class="keyword">import</span> &#123; d &#125; <span class="keyword">from</span> <span class="string">'XX'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// export default的对应导入形式</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">import</span> b <span class="keyword">from</span> <span class="string">'XX'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将所有导出变量合并成一个变量的方式</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> b = <span class="number">2</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> c <span class="keyword">from</span> <span class="string">'XX'</span></span><br><span class="line">c.a <span class="comment">// 1</span></span><br><span class="line">c.b <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h3 id="import-export-复合写法"><a href="#import-export-复合写法" class="headerlink" title="import/export 复合写法"></a>import/export 复合写法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">'XX'</span></span><br><span class="line"><span class="keyword">export</span> a</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">export</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">'XX'</span></span><br></pre></td></tr></table></figure>
<h3 id="import-export-与静态分析"><a href="#import-export-与静态分析" class="headerlink" title="import/export 与静态分析"></a>import/export 与静态分析</h3><p>在 es6 的模块化之前,commonJs 等已经有了其它的模块化方案，但是这些方案都是动态导入。即代码在运行之前其实无法判断导入有哪些变量<br>es6 规定 import 和 export 语法必须在最顶层，这样编辑器就可以静态分析出导出和导入的变量<br>所以不存在条件性的导入和导出，以下代码会报错</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="import-的加载机制"><a href="#import-的加载机制" class="headerlink" title="import 的加载机制"></a>import 的加载机制</h3><p>import 导入的变量并不是导出变量的副本，而是直接指向导出的变量，所以如果修改了模块中变量的值，导出的值也会相应改变</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    a = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; a, change &#125; <span class="keyword">from</span> <span class="string">'./b.js'</span></span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">change()</span><br><span class="line">a <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>当从一个模块中 import 一个变量时，整个模块都会被执行，然后保存在内存中，第二次导入这个模块时，并不会重新执行该模块，而是从内存中直接获取<br>上例中导入<code>./b.js</code>时，<code>./b.js</code>会被执行，即使没有导出任何变量。而之后再次导入<code>./b.js</code>，则不会再执行该文件<br>利用这个特性，可以导入无导出的模块</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">window</span>._CONFIG = &#123;</span><br><span class="line">    name: <span class="string">'hz'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./a.js'</span></span><br></pre></td></tr></table></figure>
<p>上例中引用了<code>./a.js</code>，但是并没有导入任何变量，利用的是执行<code>./a.js</code>的副作用。而且多次导入<code>./a.js</code>并不会多次执行该文件，所以可以在需要的地方放心的引用而不用担心多次执行的问题</p>
<h3 id="变量提升与循环引用"><a href="#变量提升与循环引用" class="headerlink" title="变量提升与循环引用"></a>变量提升与循环引用</h3><p>循环引用在模块的导入中是比较常见的问题，commonJs 解决这个问题的方式是缓存，es6 对这个问题的处理方式是由开发自己保证取值的可用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; bar &#125; <span class="keyword">from</span> <span class="string">'./b.js'</span></span><br><span class="line">bar()</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'say'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; say &#125; <span class="keyword">from</span> <span class="string">'./a.js'</span></span><br><span class="line">say()</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'bar'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./a.js'</span></span><br></pre></td></tr></table></figure>
<p>以上的代码执行并不会报错，因为<code>say、bar</code>都是函数声明，根据预处理规则，函数声明在代码执行之前就会被预先声明并赋值，所以虽然<code>b.js</code>中导入<code>say</code>函数时，<code>export function say(){...}</code>还没有执行，但是函数<code>say</code>已经声明，而<code>export</code>同样是声明语句，同样会在模块执行之前执行，所以在模块执行到<code>export function say(){...}</code>之前，就已经可以在<code>b.js</code>中访问到<code>say</code></p>
<p>同理，如果将函数<code>a.js</code>中的函数声明改为函数表达式，则会抛出错误</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; bar &#125; <span class="keyword">from</span> <span class="string">'./b.js'</span></span><br><span class="line">bar()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'say'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 省略b.js和main.js</span></span><br></pre></td></tr></table></figure>
<p>此时因为 let 的暂时性死区问题，b.js 中会抛出错误。这个错误不是因为函数的执行错误，而是在 let 声明的变量在赋值之前无法访问。</p>
<p>既然 import 也具有声明提升效果，所以下面这种代码是可以执行的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line">say()</span><br><span class="line"><span class="keyword">import</span> &#123; say &#125; <span class="keyword">from</span> <span class="string">'./b.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>a.js</code>中导出了函数声明<code>say</code>，以上代码是可以成功执行的。当然，强烈不建议这种做法。这里只是为了说明 import 和 export 语句的声明提升效果。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/05/basis/class/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhen Huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/05/basis/class/" itemprop="url">class</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-05T19:06:19+08:00">
                2019-05-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>class 语法介绍</p>
<h3 id="什么是-class"><a href="#什么是-class" class="headerlink" title="什么是 class"></a>什么是 class</h3><p>class 是 es6 新增的一种语法。</p>
<p>es 中 function 一直包含两种用途,类和函数。其中类的用途保存在内部属性[[Construct]]中,函数的用途保存在[[Call]]中。对于使用 function 关键字声明的函数而言，两种功能的表现是相同的。</p>
<p>class 的目的是将函数的类用途从 function 中抽取出来标准化。所以 class 无法使用 new 以外的方式调用。本质上来讲，class 是一种只具有类功能的函数。</p>
<p>有了 class 之后，不要再使用 function 来模拟类的使用。</p>
<h3 id="创建-class"><a href="#创建-class" class="headerlink" title="创建 class"></a>创建 class</h3><p>class 的创建有两种方式，一种是声明式，一种是表达式方式。<br><strong>声明式</strong><br>声明式创建的 class 类似于 let/const，在声明之前使用会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>表达式方式</strong><br>除了声明提升效果之外，表达式和声明效果的效果完全相同。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Person = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="class-的属性和方法"><a href="#class-的属性和方法" class="headerlink" title="class 的属性和方法"></a>class 的属性和方法</h3><p>从本质上来讲，class 就是 function，class 的功能大部分也可以通过 function 来模拟。所以和 function 类似，class 的属性和方法包含以下几种</p>
<ol>
<li>constructor 方法</li>
<li>实例属性和方法</li>
<li>原型方法</li>
<li>静态属性和方法</li>
</ol>
<h5 id="constructor-方法"><a href="#constructor-方法" class="headerlink" title="constructor 方法"></a>constructor 方法</h5><p>class 的目的是将函数类的功能抽取出来，constructor 方法对应的就是函数的函数体。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Person(<span class="string">'huang'</span>, <span class="number">18</span>)</span><br></pre></td></tr></table></figure>
<p>在上面声明的 Person 中,constructor 方法中就是生成新对象的代码。<br>name 和 age 属性保存在新生成对象的实例上</p>
<h5 id="实例属性和方法"><a href="#实例属性和方法" class="headerlink" title="实例属性和方法"></a>实例属性和方法</h5><p>实例属性和方法在 constructor 方法中声明。<br>实际上一般是不存在实例方法的，方法一般保存在原型上。<br>访问器属性时比较特殊的属性，声明方式和原型方法比较类似</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">        <span class="keyword">this</span>._name = name</span><br><span class="line">        <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// name是访问器属性，而不是原型方法</span></span><br><span class="line">    get name() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="原型方法"><a href="#原型方法" class="headerlink" title="原型方法"></a>原型方法</h5><p>es6 规范已经明确表明，<strong>不存在原型属性</strong>。<br>原型方法的声明方式和对象方法的声明方式相同。下例中，getName 方法保存在 Person 的 prototype 属性上</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="静态属性和方法"><a href="#静态属性和方法" class="headerlink" title="静态属性和方法"></a>静态属性和方法</h5><p>函数本身也是特殊的对象，所以也可以添加自己的属性和方法。<br>静态属性和方法就是 class 对象本身的属性和方法，而不是创建实例的属性和方法<br>在 class 中声明静态属性和方法的方式是在声明的属性和方法前加上 static</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> className = <span class="string">'Person'</span></span><br><span class="line">    <span class="keyword">static</span> getClassName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Person'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="class-继承"><a href="#class-继承" class="headerlink" title="class 继承"></a>class 继承</h3><p>通过 class 继承一个类非常简单，使用 extends 关键字即可。extends 后面不一定是一个 class，可以是任何一个包含[[Construct]]的函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Male</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name)</span><br><span class="line">        <span class="keyword">this</span>.sex = <span class="string">'male'</span></span><br><span class="line">    &#125;</span><br><span class="line">    getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getName() + <span class="keyword">this</span>.getSex()</span><br><span class="line">    &#125;</span><br><span class="line">    getSex() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sex</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Male 继承 Person 后，Male 的 prototype 对象的原型指向 Person 的 prototype 对象 ，而 Male 的原型会指向 Person</p>
<p>class 的继承包含四部分</p>
<ol>
<li>constructor 的继承</li>
<li>实例属性和方法的继承</li>
<li>原型方法的继承</li>
<li>静态属性和方法的继承</li>
</ol>
<p>对应上面 class 的属性和方法的 4 部分</p>
<h5 id="constructor-的继承"><a href="#constructor-的继承" class="headerlink" title="constructor 的继承"></a>constructor 的继承</h5><p>constructor 本身是不能被直接继承的,要调用父类的 constructor，必须使用 super()方法。在子类的 constructor 方法中，使用 this 之前必须使用先调用 super()方法，否则会报错<br>这也是 class 继承和函数模拟继承的不同之处。class 继承是先创建父类的实例，然后在父类的实例上调用子类的构造方法。而函数模拟类是先创建子类的实例，然后在实例上执行父类的构造方法，最后在实例上执行子类的构造方法。</p>
<p>如果子类省略 constructor 方法，会默认生成一个 constructor 方法，调用 super()方法并传入所有参数</p>
<h5 id="实例属性和方法的继承"><a href="#实例属性和方法的继承" class="headerlink" title="实例属性和方法的继承"></a>实例属性和方法的继承</h5><p>实例属性和方法的继承就是执行 super()方法的过程，不再赘叙。</p>
<h5 id="原型方法的继承"><a href="#原型方法的继承" class="headerlink" title="原型方法的继承"></a>原型方法的继承</h5><p>原型方法的继承是通过修改子类 prototype 属性的原型指向，使其指向父类 prototype 属性<br>这样子类的实例原型链上就包含父类的 prototype 属性</p>
<h5 id="静态方法和属性的继承"><a href="#静态方法和属性的继承" class="headerlink" title="静态方法和属性的继承"></a>静态方法和属性的继承</h5><p>class 静态方法和属性的继承是通过将子类的原型对象指向父类</p>
<p>继承的完整图形如下所示<br><img src="/images/class继承.png" alt="class继承图"><br>由上图可以发现，抛开 function 本身的原型系统,继承只做了两件事情，一个是将子类的原型指向父类，另一个是将子类的 prototype 对象的原型指向父类的 prototype 对象</p>
<h5 id="super"><a href="#super" class="headerlink" title="super"></a>super</h5><p>super 有两种用途，一种是在子类的 constructor 方法内直接调用 super()方法，此时会调用父类的 constructor 方法<br>另一种是在子类的方法中通过 super.XXX()方式调用父类的方法，包括子类的静态方法中也可以使用 super.XXX()方式。同样的方式也可以在对象的方法中使用。</p>
<p>第一种用途的 super 指向明确，指向父类的 constructor 方法<br>第二种用途的 super 指向方法所属对象的原型<br>关于方法，只有使用属性简写方式的函数属性才是方法，才有所属对象。class 中函数也是使用属性简写方式声明，所以 class 中定义的也是方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name()&#123;&#125; <span class="comment">// 这是方法</span></span><br><span class="line">    age:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// 不是属性简写方式，不是方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>class 中的方法定义在 class 的 prototype 属性上，所以 class 内定义的方法所属对象是 class 的 prototype 属性，class 的 prototype 属性的原型指向父类的 prototype 属性。所以 super 指向的是父类 prototype 属性，通过 super.XXX 可以访问父类的 prototype 属性上的方法。</p>
<h3 id="class-模拟实现"><a href="#class-模拟实现" class="headerlink" title="class 模拟实现"></a>class 模拟实现</h3><p>完整模拟 class 的实现是不行的，因为 class 的实现中是先创建父类实例，然后以父类实例为 this 执行子类构造函数。而模拟实现中只能下创建子类实例，然后以子类实例为 this 执行父类的构造函数，最后执行子类的构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等同于以下实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Person = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span>.target === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'构造函数不能使用new以外的方式调用'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">'getName'</span>, &#123;</span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        configrable: <span class="literal">true</span>,</span><br><span class="line">        value() &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">new</span>.target !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'方法不能使用new调用'</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> Person</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>继承的模拟实现也比较简单，除了子类的构造函数中需要调用父类的构造函数外，只需要使用 Object.setPrototypeOf 将子类和子类的 prototype 的原型分别指向父类和父类的 prototype</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Male</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name)</span><br><span class="line">        <span class="keyword">this</span>.sex = <span class="string">'male'</span></span><br><span class="line">    &#125;</span><br><span class="line">    getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getName() + <span class="keyword">this</span>.getSex()</span><br><span class="line">    &#125;</span><br><span class="line">    getSex() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sex</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模拟实现如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person部分省略</span></span><br><span class="line"><span class="keyword">let</span> Male = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Male = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        Person.call(<span class="keyword">this</span>, name)</span><br><span class="line">        <span class="keyword">this</span>.sex = <span class="string">'male'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略定义getName和getSex方法，类似于Person getName的模拟实现</span></span><br><span class="line">    <span class="built_in">Object</span>.setPrototypeOf(Male, Person)</span><br><span class="line">    <span class="built_in">Object</span>.setPrototypeOf(Male.prototype, Person.prototype)</span><br><span class="line">    <span class="keyword">return</span> Male</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/basis/json/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhen Huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/basis/json/" itemprop="url">JSON</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T12:04:06+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse"></a>JSON.parse</h3><p>JSON.parse 报错的处理方法,多半是换行之类的作怪</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str = str.replace(<span class="regexp">/\\/g</span>, <span class="string">'\\\\'</span>)</span><br><span class="line">str = str.replace(<span class="regexp">/\r/g</span>, <span class="string">'\\r'</span>)</span><br><span class="line">str = str.replace(<span class="regexp">/\n/g</span>, <span class="string">'\\n'</span>)</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/14/basis/promise/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhen Huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/14/basis/promise/" itemprop="url">Promise</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-14T18:51:27+08:00">
                2019-04-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是-Promise"><a href="#什么是-Promise" class="headerlink" title="什么是 Promise"></a>什么是 Promise</h3><p>Promise 是 es6 中一种新的数据类型/结构，目的在于解决回调方式的一些问题，如回调地狱、控制权反转。</p>
<p>Promise 包含三种状态<code>pending</code>、<code>fulfilled</code>、<code>rejected</code>。Promise 一旦变成<code>fulfilled</code>或者<code>rejected</code>，状态就不能在改变。这也是 Promise 命名的来源，即状态只会改变一次。<br><code>fulfilled</code> 状态表示成功状态，<code>rejected</code> 表示失败状态。</p>
<p>Promise 包含一个值，在创建 Promise 时生成。具体见 <strong>创建 Promise</strong></p>
<h3 id="创建-Promise"><a href="#创建-Promise" class="headerlink" title="创建 Promise"></a>创建 Promise</h3><p>创建 Promise 有两种方式<br>一种是通过构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">123</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Promise 构造函数接受一个函数，函数接受两个参数，resolve 会决议传入的值，具体行为类似于 Promise.resolve，区别在于 resolve 方法永远返回一个新的 Promsie<br>reject 将 Promsie 变为<code>rejected</code>状态。<br>resolve 和 reject 的参数就是 Promise 的值</p>
<p>另外一种是通过 Promise 的静态方法<code>Promise.resolve</code>和<code>Promise.reject</code><br><code>Promise.reject</code> 会创建一个 <code>rejected</code> 状态的 Promise</p>
<p>对于 <code>Promise.resolve</code>，有一点不同。<br>resolve 在英文中的意思是决议，规范最后选择 resolve 而不是 fulfill，是因为<code>Promise.resolve</code>的意思更接近于决议，而不是成功完成。</p>
<p><code>Promise.resolve</code>根据传入的参数不同会做不同的处理。</p>
<p>如果传入的是一个 Promise，Promise.resolve 会直接返回这个 Promise<br>如果传入的是包含 then 方法的对象，会使用 Promise 的构造函数创建一个新的 Promise，以 then 方法作为构造函数的参数<br>否则返回状态 fulfilled，值为 Promise.resolve 参数的 Promise</p>
<h3 id="then-方法"><a href="#then-方法" class="headerlink" title="then 方法"></a>then 方法</h3><p>Promise 最重要的方法是 then 方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">123</span>).then(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(val)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>then 方法接受两个参数，分别表示 fulfilled 和 rejected 状态下的执行函数<br>其中的 val 和 err 就是 Promise 在不同状态下的值。参数可以是普通函数，也可以箭头函数。</p>
<p>then 方法的两个参数都可以省略，如果不想传入第一个参数，可以传入 null 或者 undefined 等</p>
<p>then 方法返回一个 Promise，所以 Promise 可以一直串联下去</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">123</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(val) <span class="comment">// 123</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">456</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        val <span class="comment">// 456</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>then 方法第一个参数不仅可以返回数值和普通对象作为下一个 Promise 的值，还可以返回一个 Promise<br>如果返回的是一个 Promise，则 then 方法的状态和值取决于返回 Promise 的状态和值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">123</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="number">999</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="literal">null</span>, err =&gt; &#123;</span><br><span class="line">        err <span class="comment">// 999</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>如果 Promise 的值在 then 方法没有参数处理，则会一直像后传递。所以可以在 Promise 链的最后添加一个错误处理函数，处理之前所有 Promise 抛出的错误</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">123</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 不会被执行</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="literal">null</span>, err =&gt; &#123;</span><br><span class="line">        err <span class="comment">// 这里处理错误</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p><code>then</code>方法一个非常重要的特点是<code>then</code>的回调永远是异步的。准确来讲是在当前事件循环结束的微任务中执行。</p>
<h3 id="catch、Promise-all、Promise-race"><a href="#catch、Promise-all、Promise-race" class="headerlink" title="catch、Promise.all、Promise.race"></a>catch、Promise.all、Promise.race</h3><p>前例中在 Promise 链最后添加错误处理函数的情况十分普通，所以 es6 为 Promise 增加了 catch 方法。catch 方法等同于 then(null)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resovle(<span class="number">123</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure>
<p><code>Promise.all</code> 接受一个 Promise 数组，返回一个 Promise。数组的所有 Promsie 都变为 fulfilled 状态后，返回 Promise 的状态变为 fulfilled，值为数组所有 Promise 值的数组。其中任意一个 Promise 变为 rejected，返回 Promise 的状态变为 rejected。</p>
<p>Promise.race 同样返回一个 Promise，返回的 Promise 在任何一个 Promise 决议后决议，决议的结果就是返回 Promise 的结果。</p>
<h3 id="Promise-的问题"><a href="#Promise-的问题" class="headerlink" title="Promise 的问题"></a>Promise 的问题</h3><p>Promise 最大的问题在于会吞掉错误。即如果 Promise 内部抛出了错误，如果错误没有被 catch 方法处理，错误也不会冒泡到 Promise 外部。</p>
<p>这种设计的原因在于 Promise 被设计为在任何时候添加 then 方法都可以获取 Promise 决议的值。所以即使 Promise 内部报错了，引擎也不能确定将来是不是会存在一个 catch 方法来捕获这个错误，所以不能讲错误抛出。</p>
<p>这种设计有时候会导致 Promise 的异常被吞掉。所以最佳实践是永远在 Promise 链的最后添加一个 catch 方法。</p>
<p>在浏览器和 nodejs 中都有事件可以监听未捕获的 Promise 错误。</p>
<p>浏览器中的事件如下<br><code>unhandledrejection</code>,同一个事件循环中，Promise 被拒绝，没有提供拒绝处理程序时触发<br><code>rejectionhandled</code>,一个事件循环后，拒绝的 Promise 被处理时触发</p>
<p>nodejs 的事件与浏览器中基本一致，只是事件名是驼峰格式</p>
<h3 id="Promise-的实现"><a href="#Promise-的实现" class="headerlink" title="Promise 的实现"></a>Promise 的实现</h3><p>完全模拟实现 Promise 是不可能的，因为 Promise 的 then 虽然永远是异步的，但是在事件循环中 Promise 属于微任务，setTimeout 属于宏任务，所以无法完全模拟。</p>
<p>以下是一个 Promise 的模拟实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _status = <span class="built_in">Symbol</span>(<span class="string">'status'</span>)</span><br><span class="line"><span class="keyword">const</span> _value = <span class="built_in">Symbol</span>(<span class="string">'value'</span>)</span><br><span class="line"><span class="keyword">const</span> _fulfilledQueue = <span class="built_in">Symbol</span>(<span class="string">'fulfilledQueue'</span>)</span><br><span class="line"><span class="keyword">const</span> _rejectedQueue = <span class="built_in">Symbol</span>(<span class="string">'rejectedQueue'</span>)</span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="built_in">Symbol</span>(<span class="string">'pending'</span>)</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="built_in">Symbol</span>(<span class="string">'fulfilled'</span>)</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="built_in">Symbol</span>(<span class="string">'rejected'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(handler) &#123;</span><br><span class="line">        <span class="keyword">this</span>[_status] = PENDING</span><br><span class="line">        <span class="keyword">this</span>[_value] = <span class="string">''</span></span><br><span class="line">        <span class="keyword">this</span>[_fulfilledQueue] = []</span><br><span class="line">        <span class="keyword">this</span>[_rejectedQueue] = []</span><br><span class="line">        <span class="keyword">const</span> reject = <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>[_status] !== PENDING) <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">this</span>[_status] = REJECTED</span><br><span class="line">            <span class="keyword">this</span>[_value] = err</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> cb <span class="keyword">of</span> <span class="keyword">this</span>[_rejectedQueue]) &#123;</span><br><span class="line">                    cb(<span class="keyword">this</span>[_value])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> resolve = <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>[_status] !== PENDING) <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">this</span>[_status] = FULFILLED</span><br><span class="line">            <span class="keyword">this</span>[_value] = val</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> cb <span class="keyword">of</span> <span class="keyword">this</span>[_fulfilledQueue]) &#123;</span><br><span class="line">                    cb(<span class="keyword">this</span>[_value])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            handler(resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    then(onResolve, onRejected) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">nextResolve, nextReject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> _onResolve = <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">typeof</span> onResolve !== <span class="string">'function'</span>) &#123;</span><br><span class="line">                        nextResolve(val)</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">let</span> result = onResolve(val)</span><br><span class="line">                    <span class="keyword">if</span> (result <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                        result.then(nextResolve, nextReject)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        nextResolve(result)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    nextReject(error)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> _onReject = <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected !== <span class="string">'function'</span>) &#123;</span><br><span class="line">                        nextReject(err)</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">let</span> result = onRejected(err)</span><br><span class="line">                    <span class="keyword">if</span> (result <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                        result.then(nextResolve, nextReject)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        nextResolve(result)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    nextReject(error)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>[_status] === PENDING) &#123;</span><br><span class="line">                <span class="keyword">this</span>[_fulfilledQueue].push(_onResolve)</span><br><span class="line">                <span class="keyword">this</span>[_rejectedQueue].push(_onReject)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>[_status] === FULFILLED) &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    _onResolve(<span class="keyword">this</span>[_value])</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>[_status] === REJECTED) &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    _onReject(<span class="keyword">this</span>[_value])</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(handler) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">undefined</span>, handler)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span>(handler) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">            val =&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> MyPromise.resolve(handler()).then(<span class="function"><span class="params">()</span> =&gt;</span> val)</span><br><span class="line">            &#125;,</span><br><span class="line">            err =&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> MyPromise.resolve(handler()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> err</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> resolve(val) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(val))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> reject(err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(err))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> all(args) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> resolvedCount = <span class="number">0</span>,</span><br><span class="line">                resolveValueQueue = []</span><br><span class="line">            <span class="keyword">const</span> onResolved = <span class="function">(<span class="params">val, index</span>) =&gt;</span> &#123;</span><br><span class="line">                resolveValueQueue[index] = val</span><br><span class="line">                resolvedCount++</span><br><span class="line">                <span class="keyword">if</span> (resolvedCount == args.length) &#123;</span><br><span class="line">                    resolve(resolveValueQueue)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> onRejected = <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                reject(err)</span><br><span class="line">            &#125;</span><br><span class="line">            args.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">                MyPromise.resolve(item).then(<span class="function"><span class="params">val</span> =&gt;</span> onResolved(val, index), onRejected)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> race(args) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> onResolved = <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">                resolve(val)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> onRejected = <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                reject(err)</span><br><span class="line">            &#125;</span><br><span class="line">            args.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">                MyPromise.resolve(item).then(onResolved, onRejected)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> MyPromise</span><br></pre></td></tr></table></figure>
<p>整体思路是对状态的值的改变是同步，回调是异步，然后 then 方法的回调同样要异步(处理 FULFILLED 状态后添加的 then 方法)。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/28/basis/generator/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhen Huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/28/basis/generator/" itemprop="url">生成器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-28T19:52:57+08:00">
                2019-03-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h3 id="什么是生成器"><a href="#什么是生成器" class="headerlink" title="什么是生成器"></a>什么是生成器</h3><p>生成器是一个返回迭代器的函数。<br>不同于普通的函数，生成器在声明语法和执行上都差异极大。</p>
<p>以下是一个生成器的例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">say</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> x <span class="comment">// yield是生成器内的特殊语法，只能在生成器内出现</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一点需要注意，生成器返回的不仅仅是一个迭代器，也是一个可迭代对象，所以生成器的返回值可以直接使用<code>for...of</code>遍历</p>
<h5 id="生成器的声明"><a href="#生成器的声明" class="headerlink" title="生成器的声明"></a>生成器的声明</h5><p>不同于普通的函数生成，生成器的声明需要在<code>function</code>关键字和函数名之间加上<code>*</code>。</p>
<p>对于*、function 和函数名之间的位置关系，以下三种都可以</p>
<ol>
<li><code>function* say</code></li>
<li><code>function * say</code></li>
<li><code>function *say</code></li>
</ol>
<p>对于没有<code>function</code>关键字的方法声明，<code>*</code>号放在方法名之前即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    *say() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="生成器的执行"><a href="#生成器的执行" class="headerlink" title="生成器的执行"></a>生成器的执行</h5><p>作为函数，生成器也有返回值。不同于普通的函数，生成的返回值是一个可以调度生成器执行的迭代器。</p>
<p>以以下生成器为例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">say</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> gen = say()</span><br><span class="line">gen.next() <span class="comment">// 执行 yield 1</span></span><br><span class="line"><span class="comment">// gen.next()返回值 &#123;value:1,done:false&#125;</span></span><br><span class="line">gen.next() <span class="comment">// 执行 console.log(2) yield 2</span></span><br><span class="line"><span class="comment">// &#123;value:2,done:false&#125;</span></span><br><span class="line">gen.next() <span class="comment">// 执行 yield 3</span></span><br><span class="line"><span class="comment">// &#123;value:3,done:false&#125;</span></span><br><span class="line">gen.next()</span><br><span class="line"><span class="comment">// &#123;value:undefined,done:true&#125;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>生成器 say 执行后并不立即执行函数内部代码，而是返回一个迭代器，通过执行迭代器的 next 方法，可以让生成器继续执行。</li>
<li>每次调用迭代器的 next 方法，生成器会从上次暂停的地方开始执行，直到碰到下一个 yield 语句，或者函数结束。</li>
<li>如果碰到 yield 语句，生成器将 yield 后的值作为迭代器的 value 返回，然后函数暂停，等待下一次 next 方法调用。</li>
<li>如果函数结束(执行到最后一行或者碰到 return),将 return 的值作为 value 返回，此时 done 为 true</li>
</ol>
<h3 id="next-throw-return"><a href="#next-throw-return" class="headerlink" title="next/throw/return"></a>next/throw/return</h3><p>在迭代器中讲到过，迭代器必须有 next 方法，对于生成器返回的迭代器，除了 next 方法之外，还有 throw 和 return 方法</p>
<h5 id="next"><a href="#next" class="headerlink" title="next"></a>next</h5><p>生成器中 yield 表达式本身是没有值的，或者说值都是 undefined,可以通过跟 next 方法传值给 yield 表达式赋值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">NextValue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> gen = NextValue()</span><br><span class="line">gen.next()</span><br><span class="line"><span class="comment">// &#123;value:1,done:false&#125;</span></span><br><span class="line">gen.next(<span class="number">8</span>)</span><br><span class="line"><span class="comment">// &#123;value:8,done:false&#125;</span></span><br></pre></td></tr></table></figure>
<p>如上，第一次执行 next 返回 1<br>第二次执行 next 方法传入 8，8 会被赋值给 x,所以第二次 next 返回 8</p>
<p>next 的传值对于生成器十分重要，这意味着在生成器执行过程中，仍然可以通过给生成器传递不同值从而得到不同的结果</p>
<h5 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h5><p>通过 throw 方法可以在生成器内抛出一个错误，如果生成器内部没有捕获错误，错误会冒泡到生成器之外。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">ErrorGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> gen = ErrorGenerator()</span><br><span class="line">gen.throw(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错啦'</span>))</span><br><span class="line"><span class="comment">//  Uncaught Error: 出错啦</span></span><br></pre></td></tr></table></figure>
<h5 id="return"><a href="#return" class="headerlink" title="return"></a>return</h5><p>调用迭代器的 return 方法后，生成器会直接结束，返回的 value 为 return 的传入值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">ReturnGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> gen = ReturnGenerator()</span><br><span class="line">gen.return(<span class="number">3</span>)</span><br><span class="line"><span class="comment">// &#123;value:3,done:true&#125;</span></span><br><span class="line">gen.next(<span class="number">9</span>)</span><br><span class="line"><span class="comment">// &#123;value:undefined,done:true&#125;</span></span><br></pre></td></tr></table></figure>
<h5 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h5><p>方法 next/throw/return 都可以理解为将 yield 语句替换为一段其它语句，然后继续执行</p>
<ol>
<li>next 使用 next 方法的参数替换 yield 语句</li>
<li>throw 方法用 <code>throw</code>替换 yield 语句，throw 的值为 throw 方法的参数</li>
<li>return 使用<code>return</code>语句替换 yield 语句，return 的值为 return 方法的参数</li>
</ol>
<h3 id="yield"><a href="#yield" class="headerlink" title="yield*"></a>yield*</h3><p>在生成器内部可以使用<code>yield*</code>嵌套 yield 其它可迭代对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">NestedGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">Generator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="comment">// 也可以是等其它可迭代对象</span></span><br><span class="line">    <span class="keyword">yield</span>* NestedGenerator()</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> gen = Generator()</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> gen) &#123;</span><br><span class="line">    <span class="comment">//1 2 3 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>先看一个回调函数的异步例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ajax(<span class="string">'a/b/c'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    handle(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">123</span>)</span><br></pre></td></tr></table></figure>
<p>setTimeout 需要传入一个回调函数。回调函数的方式缺点很多，这里只指出生成器能解决的最重要的一条。</p>
<p>回调函数的执行顺序不符合直觉。</p>
<p>代码<code>handle(res)</code>位于<code>console.log(123)</code>之前，执行却在<code>console.log(123)</code>之后。</p>
<p>先看一下上面的代码用生成器执行应该怎么写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ajax(<span class="string">'a/b/c'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            it.throw(err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        it.next(res)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">runTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="keyword">yield</span> request()</span><br><span class="line">    handle(x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = runTask()</span><br><span class="line">it.next()</span><br></pre></td></tr></table></figure>
<p>第一眼的感觉这段代码比回调的复杂很多，而且也不是很好理解。</p>
<p>继续之前，先梳理下这段代码的逻辑</p>
<ol>
<li>it.next()执行了 request 方法</li>
<li>request 方法执行了一个异步方法 ajax(假设存在这样一个异步方法)</li>
<li>在异步方法的回调函数中调用了 it.next，传入了回调函数的返回值 res</li>
<li>res 被赋值给 x,handle(x)是真正处理 ajax 返回值的代码</li>
</ol>
<p>上例中处理异步的核心代码其实只有两行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="keyword">yield</span> request()</span><br><span class="line">handle(x)</span><br></pre></td></tr></table></figure>
<p>这两行代码独特的地方在于它完全没有涉及异步、回调。就好像这是一个同步调用一样。</p>
<p>当然，上面的代码过于麻烦，而且硬编码严重，不具有通用性，可以改造如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改造后的生成器异步代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">tasks</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> it = tasks(),</span><br><span class="line">        result = it.next()</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (result.done) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> result.value === <span class="string">'function'</span>) &#123;</span><br><span class="line">            result.value(<span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                    it.throw(err)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                result = it.next(res)</span><br><span class="line">                step()</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = it.next(result.value)</span><br><span class="line">            step()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    step()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        ajax(<span class="string">'a/b/c'</span>, callback)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="keyword">yield</span> request()</span><br><span class="line">    handle(x)</span><br><span class="line">&#125;</span><br><span class="line">run(main)</span><br></pre></td></tr></table></figure>
<p>改造后的代码更加复杂了，但是通用性更强。<code>run</code>方法完全通用，<code>request</code>方法可以用一个工厂方法生成。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestFactory</span>(<span class="params">func, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        func(...args, callback)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改后的<code>request</code>方法如下所示</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改前</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        ajax(<span class="string">'a/b/c'</span>, callback)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="keyword">yield</span> request()</span><br><span class="line">    handle(x)</span><br><span class="line">&#125;</span><br><span class="line">run(main)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestFactory</span>(<span class="params">func, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        func(...args, callback)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="keyword">yield</span> requestFactory(ajax, <span class="string">'a/b/c'</span>)</span><br><span class="line">    handle(x)</span><br><span class="line">&#125;</span><br><span class="line">run(main)</span><br></pre></td></tr></table></figure>
<p>至此，<code>run</code>和<code>requestFactory</code>都成了通用方法，真正的执行代码只有生成器<code>main</code>方法和<code>run(main)</code>语句。</p>
<p>在上面的<code>run</code>方法中，我们一直有一个假设，即<code>ajax</code>异步方法接收的回调是 error-first 风格的。写出这样风格的异步方法不难，但是也总是难免会存在不是这种风格的回调。但要在<code>run</code>方法中判断回调的第一个参数是不是错误很难，或者说不可能。<br>所以对于<code>run</code>方法的回调方法的参数必须有所约定，<code>Promise</code>是最好的选择。即<code>requestFactory</code>方法需要返回一个 Promise,或者 ajax 方法直接返回<code>Promise</code></p>
<p>最终的代码如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">tasks</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> it = tasks(),</span><br><span class="line">        result = it.next()</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (result.done) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">            result.value.then(</span><br><span class="line">                res =&gt; &#123;</span><br><span class="line">                    result = it.next(res)</span><br><span class="line">                    step()</span><br><span class="line">                &#125;,</span><br><span class="line">                err =&gt; &#123;</span><br><span class="line">                    it.throw(err)</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = it.next(result.value)</span><br><span class="line">            step()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    step()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="keyword">yield</span> ajax(<span class="string">'a/b/c'</span>) <span class="comment">// ajax需要返回一个Promise</span></span><br><span class="line">    handle(x)</span><br><span class="line">&#125;</span><br><span class="line">run(main)</span><br></pre></td></tr></table></figure>
<p>其中<code>run</code>方法可以封装为一个工具函数。</p>
<p>es7 将这种异步方式规范化了。没错，就是<code>async await</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/25/basis/iterator/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhen Huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/25/basis/iterator/" itemprop="url">迭代器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-25T20:29:15+08:00">
                2019-03-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h3 id="什么是迭代器"><a href="#什么是迭代器" class="headerlink" title="什么是迭代器"></a>什么是迭代器</h3><p>在 js 中，遍历数组的一种常用方式是通过<code>index</code>，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    arr[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这也是 es6 之前遍历类数组结构的常用方法。<br>es6 中引入了两种新的数据结构，<code>Set</code>和<code>Map</code>。对于<code>Set</code>和<code>Map</code>，不能通过下标访问元素，所以遍历 Set 和 Map 需要一种新的方法，最好这种方法还能够和类数组结构兼容。<br>所以 es6 定义了一种新的遍历方式<code>for...of</code>。而<code>for...of</code>的遍历正是通过迭代器来实现。</p>
<p><strong>迭代器是一个普通对象</strong>，必须包含<code>next</code>方法，可以包含<code>return/throw</code>方法。<br>执行迭代器的<code>next</code>方法返回一个对象，包含两个属性<code>value、done</code>，其中<code>value</code>表示值,<code>done</code>表示遍历是否结束。<br>在遍历结束之前，<code>done</code>都会返回<code>false</code>。<code>done</code>返回<code>true</code>则代表遍历结束。</p>
<p>下面是一个简单的迭代器示例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> iteratorExmaple = &#123;</span><br><span class="line">    next() &#123;</span><br><span class="line">        <span class="keyword">if</span> (i++ &lt;= 5) &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                value: i,</span><br><span class="line">                done: false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;</span><br><span class="line">            value: i,</span><br><span class="line">            done: true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在循环<code>for(let item of arr)</code>中，<code>for...of</code>循环会调用 arr 迭代器的<code>next</code>方法，把<code>value</code>的值赋给<code>item</code>，直到<code>next</code>方法返回的对象<code>done</code>为 true。(arr 的迭代器从何而来，后面会讲到)<br>注意：<strong>done 为 true 时的 value 值不会包含在 for…of 循环中</strong></p>
<h3 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h3><p>js 中有很多类型都是可迭代对象，包括数组、类数组结构如 NodeList,arguments、字符串、Set、Map。<br>普通对象不是。</p>
<p>迭代器也不是，迭代器不能被<code>for...of</code>循环遍历。</p>
<p>一个对象是不是可迭代对象取决于对象是不是包含<code>Symbol.iterator</code>方法。<code>Symbol.iterator</code>方法需要返回一个迭代器，<code>for...of</code>遍历基于这个迭代器循环遍历。<br>所以可以通过以下方式让一个普通对象也可以<code>for...of</code>遍历</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            i: <span class="number">0</span>,</span><br><span class="line">            next() &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.i++ &lt; 5) &#123;</span><br><span class="line">                    return &#123;</span><br><span class="line">                        value: this.i,</span><br><span class="line">                        done: false</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                return &#123;</span><br><span class="line">                    done: true</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">for (let item of obj) &#123;</span><br><span class="line">    console.log(item) // 1 2 3 4 5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内建的可迭代对象默认拥有<code>Symbol.iterator</code>属性，一般都位于对象的原型上，所以都可以通过<code>for...of</code>遍历。</p>
<p>诸如<code>Set.keys()</code>方法返回的是迭代器，但是其可以被<code>for...of</code>遍历不是因为是迭代器，而是这个迭代器包含<code>Symbol.iterator</code>属性。</p>
<p>重要的事情说三遍:<br><strong>迭代器不是可迭代对象，不能被<code>for...of</code>循环遍历</strong></p>
<h3 id="使用迭代器的其它场合"><a href="#使用迭代器的其它场合" class="headerlink" title="使用迭代器的其它场合"></a>使用迭代器的其它场合</h3><p>虽然上面的例子中一直以<code>for...of</code>为迭代器的使用例子，但是还有一些其它情况也会调用迭代器接口</p>
<ol>
<li>展开运算符 <code>...</code></li>
<li>yield * 。生成器的内部方法，具体参考生成器。</li>
<li>Array.from()</li>
</ol>
<p>还有一些其它场合，基本上 es6 之后新的遍历都会使用迭代器</p>
<h3 id="内建迭代器"><a href="#内建迭代器" class="headerlink" title="内建迭代器"></a>内建迭代器</h3><p>js 中,Array、Set、Map 都包含有内建的迭代器 entries(),values(),keys()</p>
<p>其中 keys 返回键的迭代器，但是仍然可以被 for…of 遍历，因为 keys 返回的也是一个可迭代对象。values()和 entries()也类似<br>values()返回值的迭代器<br>entries()返回键值对数组的迭代器</p>
<h3 id="迭代器的高级用法"><a href="#迭代器的高级用法" class="headerlink" title="迭代器的高级用法"></a>迭代器的高级用法</h3><p>迭代器的高级用法，如迭代器的 throw 方法，迭代器 next 方法传参，几乎都与生成器相关。所以放在生成器中一起讲。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/19/basis/type-cast/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhen Huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/19/basis/type-cast/" itemprop="url">类型转换</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-19T20:57:14+08:00">
                2019-03-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h3><p>Number Boolean String Object</p>
<h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h3><h3 id="装箱转换-拆箱转换"><a href="#装箱转换-拆箱转换" class="headerlink" title="装箱转换/拆箱转换"></a>装箱转换/拆箱转换</h3><h3 id="抽象转换-ToNumber-ToString-ToPrimitive-ToBoolean"><a href="#抽象转换-ToNumber-ToString-ToPrimitive-ToBoolean" class="headerlink" title="抽象转换 ToNumber ToString ToPrimitive ToBoolean"></a>抽象转换 ToNumber ToString ToPrimitive ToBoolean</h3><p><code>ToNumber ToString</code> 只是 <code>ToPrimitive</code>的一种情况<br><code>ToBoolean</code> 不属于其中，有一套独立的规则<br><code>ToPrimitive</code>可以理解为就是<code>Symbol.toPrimitive</code>函数的结果</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.toPrimitive](hint) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (hint) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'default'</span>:</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'default'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'string'</span>:</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'string'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'number'</span>:</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'number'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">console</span>.log(hint)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'toString'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">    &#125;,</span><br><span class="line">    valueOf() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'valueOf'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">6</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Number</span>(obj) <span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">String</span>(obj) <span class="comment">// 2</span></span><br><span class="line">    obj + <span class="number">1</span> <span class="comment">// 1+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Symbol.toPrimitive</code>传入的<code>hint</code>只有<code>string/number/default</code>三种情况，<code>default</code>只是为了代码完备。<br><code>Symbol.toPrimitive</code>的返回结果就是<code>Number(obj)</code>等的返回结果,如果返回的不是<code>hint</code>的基本类型，会强制转换为<code>hint</code>类型(可能会失败，如<code>Symbol</code>转数字)，如果返回的是对象，会抛出错误。<br><code>toString</code>和<code>valueOf</code>方法不会执行。</p>
<p>默认<code>Symbol.toPrimitive</code>情况下，根据不同的<code>hint</code>,会先后调用<code>valueOf</code>和<code>toString</code>，只要有一个返回基本类型，就会将该基本类型强制转换为<code>hint</code>类型，如果两者都返回对象，报错。至于调用的先后顺序，<code>string</code>是<code>toString-valueOf</code>，<code>number</code>相反，<code>default</code>在<code>Date</code>对象中是<code>toString</code>优先，其它是<code>valueOf</code>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/19/basis/set-map/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhen Huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/19/basis/set-map/" itemprop="url">Set和Map</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-19T19:24:25+08:00">
                2019-03-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set 是 es6 定义的一种新的数据结构，概念上与数组很类似，但是操作上与数组截然不同。</p>
<p>Set 最重要的特性是<strong>不包含重复元素</strong>，如果不需要这种特性，一般没有使用 Set 的需要。Set 内部使用<code>Object.is</code>来比较两个元素是否相等，而不是<code>===</code>,<code>Object.is</code>和<code>===</code>的区别在于<code>NaN</code>和自己相等以及<code>-0</code>和<code>+0</code>不相等。</p>
<h5 id="创建-Set"><a href="#创建-Set" class="headerlink" title="创建 Set"></a>创建 Set</h5><p>创建 Set 只能使用构造函数的方式<code>new Set()</code>。也可以传入<code>iterable</code>对象，Set 会将迭代对象去重。如果传入的内容不能迭代，会抛出错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>]) <span class="comment">// set([1,2,4])</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>(<span class="number">3</span>) <span class="comment">// error 3 is not iterable</span></span><br></pre></td></tr></table></figure>
<h5 id="操作-Set"><a href="#操作-Set" class="headerlink" title="操作 Set"></a>操作 Set</h5><p>Set<strong>不是</strong>数组，不能够通过索引直接获取某个位置的值。<br>操作数组的方法包括</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">add()</td>
<td style="text-align:center">添加值</td>
</tr>
<tr>
<td style="text-align:center">delete()</td>
<td style="text-align:center">删除值</td>
</tr>
<tr>
<td style="text-align:center">has()</td>
<td style="text-align:center">是否包含某个值</td>
</tr>
<tr>
<td style="text-align:center">clear()</td>
<td style="text-align:center">清空 Set</td>
</tr>
<tr>
<td style="text-align:center">size</td>
<td style="text-align:center">Set 的值个数</td>
</tr>
</tbody>
</table>
<p>由于<code>add</code>方法返回Set本身，对于连续添加多个元素可以采用如下方式<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">set.add(<span class="number">1</span>).add(<span class="number">2</span>).add(<span class="number">3</span>)</span><br></pre></td></tr></table></figure></p>
<p>Set 还包含<code>forEach</code>方法。但是由于 Set 没有索引，<code>forEach</code>的<code>key</code>和<code>value</code>相同，所以几乎没有任何理由使用<code>forEach</code>。同理，<code>set.keys()/set.values()/set.entries()</code>也毫无意义。遍历 Set 最好的方式是使用<code>for...of</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> s) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，Set 唯一的作用是否就是确认是否包含某个变量，但是这个功能数组也能轻易做到，<code>arr.includes()</code>和<code>set.has()</code>功能相同。<br>ps:和<code>arr.indexOf()</code>有一点区别,<code>indexOf</code>使用<code>===</code>判别是不是同一个元素,<code>includes</code>使用<code>Object.is()</code>，所以数组的<code>includes</code>和<code>indexOf</code>还是有一点区别的</p>
<p>Set 唯一的作用大概是用来去重</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">[...new <span class="built_in">Set</span>(arr)] <span class="comment">// [1,2,3,4]</span></span><br></pre></td></tr></table></figure>
<p>除此之外，似乎没有其他用途了</p>
<h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><p>WeakSet 正如其名，与 Set 基本相同，区别有两点</p>
<ol>
<li>WeakSet 只能包含对象，不能包含基本类型，给 WeakSet 添加基本类型会报错</li>
<li>WeakSet 不是可遍历对象，不包含<code>clear()</code>和<code>size</code>方法/属性</li>
</ol>
<p>所以 WeakSet 只有三个方法<code>add/has/delete</code></p>
<p>WeakSet 最大的特点是只会保存持有对象的弱引用。即如果 WeakSet 持有的对象不被其他变量引用，则该对象可以被回收。<br>个人对WeakSet的用途暂只限于判断对象是否被回收。直接<code>console.log(weakset)</code>可以判断<code>WeakSet</code>包含的变量是否被回收。（不被引用的变量不一定马上被回收，这种方法判断依赖回收机制的触发，需要一定时间差）</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map 和 Set 经常被一起提及，但是两者其实没什么关联。除了语法上的类似外，唯一是关系大概是都是 es6 添加的新数据结构。</p>
<p>如果说 Set 是参照数组创建的，Map 是参照对象创建的。Map也是键值对的组合，与对象的区别在于对象的<code>key</code>只能是字符串，而Map的<code>key</code>可以是任意数据类型</p>
<h5 id="创建-Map"><a href="#创建-Map" class="headerlink" title="创建 Map"></a>创建 Map</h5><p>创建 Map 也只能通过<code>new Map()</code>的方式。如果要给Map传入初始值，可以传入每个元素都是数组的数组<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'key'</span>,<span class="string">'value'</span>],[<span class="number">1</span>,&#123;&#125;]])</span><br></pre></td></tr></table></figure></p>
<h5 id="操作Map"><a href="#操作Map" class="headerlink" title="操作Map"></a>操作Map</h5><p>Map不能通过属性名<code>.</code>或者<code>[]</code>语法直接访问属性。Map的操作方法和Set及其相似。</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">set(key,val)</td>
<td style="text-align:center">添加/更新key的值为val</td>
</tr>
<tr>
<td style="text-align:center">get(key)</td>
<td style="text-align:center">获取key的val</td>
</tr>
<tr>
<td style="text-align:center">delete(key)</td>
<td style="text-align:center">删除key</td>
</tr>
<tr>
<td style="text-align:center">has(key)</td>
<td style="text-align:center">是否包含key</td>
</tr>
<tr>
<td style="text-align:center">clear()</td>
<td style="text-align:center">清空 Map</td>
</tr>
<tr>
<td style="text-align:center">size</td>
<td style="text-align:center">Map的键值对数量</td>
</tr>
</tbody>
</table>
<p>除了<code>add</code>方法变成了<code>set/get</code>，其它的方法完全一样。Map同样是<code>iterable</code>对象，支持<code>iterable</code>的所有遍历方式。<br>Map的get方法返回Map本身，同样可以采用链式方式添加多个元素<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="number">1</span>,<span class="number">1111</span>).set(<span class="number">2</span>,<span class="number">2222</span>)</span><br></pre></td></tr></table></figure></p>
<p>Map最大的作用在于<code>key</code>可以不是字符串，在需要使用非字符串<code>key</code>时，如<code>Symbol</code>，Map还是很有作用的。</p>
<h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><p>WeakMap是Map的弱引用版本，与WeakSet类似</p>
<ol>
<li>WeakMap的<code>key</code>只能是对象</li>
<li>WeakMap不是可遍历对象</li>
</ol>
<p>WeakMap的<code>key</code>也是弱引用，即如果WeakMap的<code>key</code>不再被其它变量引用，WeakMap的<code>key</code>可以被回收。<br>WeakMap的<code>value</code>是强引用，即只要WeakMap的<code>key</code>存在，WeakMap的<code>value</code>就不会被回收。</p>
<p>与WeakSet类似，WeakMap只支持<code>set/get/delete/has</code>四个方法</p>
<p>WeakMap一个很常用的应用场景是给页面上的元素添加对应值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> el = <span class="built_in">document</span>.querySelector(<span class="string">'#xiaogou'</span>),</span><br><span class="line">    m = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    m.set(el,&#123;</span><br><span class="line">        id:<span class="string">'xiaogou'</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>在不使用Map的情况下，如果元素<code>#xiaogou</code>被删除，对象<code>{id:&#39;xiaogou&#39;}</code>很难被回收，只能在元素被移除时通过事件触发来处理，而且这种处理也不够准确，因为元素仍然可能被重新添加会<code>DOM</code>中。而WeakMap几乎可以完美的解决这个问题。</p>
<p>还有类似场景是私有变量的处理。具体代码就不列出了。<br>WeakMap的使用场景一般在需要为对象保存关联信息，对象删除时可以自动删除关联信息。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/14/basis/symbol/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhen Huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/14/basis/symbol/" itemprop="url">symbol</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-14T19:09:41+08:00">
                2019-03-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h3 id="什么是-Symbol"><a href="#什么是-Symbol" class="headerlink" title="什么是 Symbol"></a>什么是 Symbol</h3><p><code>Symbol</code>是 js 中第 7 种数据类型，第 6 种基本类型。Symbol 的主要目的是取代 js 中的魔法字符串。因为传统的对象属性只能是字符串，很容易被意外的覆盖，而 Symbol 类型的值都是独一无二的，可以有效防止意外修改对象属性的问题。</p>
<p>检测是否是 Symbol 可以用<code>typeof</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> sy === <span class="string">'symbol'</span></span><br></pre></td></tr></table></figure>
<h3 id="创建-Symbol"><a href="#创建-Symbol" class="headerlink" title="创建 Symbol"></a>创建 Symbol</h3><p><code>Symbol</code>是一种基本类型，没有构造函数，不能通过<code>new Symbol()</code>的方式创建。创建<code>Symbol</code>的方式有两种。<br>一种是通过<code>Symbol()</code>方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sy = <span class="built_in">Symbol</span>(<span class="string">'description'</span>),</span><br><span class="line">    sy2 = <span class="built_in">Symbol</span>(<span class="string">'description'</span>)</span><br><span class="line">sy === sy2 <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>其中<code>description</code>只是用于描述创建的 Symbol，对 Symbol 的值没有任何影响，创建两个 Symbol 传入相同的 description 得到的是不同的 Symbol。</p>
<p>第二种创建 Symbol 的方式是通过<code>Symbol.for()</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sy = <span class="built_in">Symbol</span>.for(<span class="string">'description'</span>),</span><br><span class="line">    sy2 = <span class="built_in">Symbol</span>.for(<span class="string">'description'</span>)</span><br><span class="line">sy === sy2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>其中的<code>description</code>既是 Symbol 的标识符，也是描述。<code>Symbol.for()</code>会先查找是否存在相同标识符的 Symbol,如果存在就返回，如果不存在就创建一个新的 Symbol。<br>注意：只有<code>Symbol.for()</code>创建的 Symbol 才会有标识符，<code>Symbol()</code>创建的 Symbol 没有标识符。所以</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sy = <span class="built_in">Symbol</span>(<span class="string">'123'</span>),</span><br><span class="line">    sy2 = <span class="built_in">Symbol</span>.for(<span class="string">'123'</span>)</span><br><span class="line">sy === sy2 <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="操作-Symbol"><a href="#操作-Symbol" class="headerlink" title="操作 Symbol"></a>操作 Symbol</h3><p>Symbol 没有对应的内置对象类型，所以 Symbol 实例没有额外的方法，几乎不能执行任何操作。除了<code>Object.prototype</code>上的<code>toString</code>等几个方法外，Symbol 还有一个<code>Symbol.keyFor()</code>方法，用于获取 Symbol 的标识符</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sy = <span class="built_in">Symbol</span>(<span class="string">'123'</span>),</span><br><span class="line">    sy2 = <span class="built_in">Symbol</span>.for(<span class="string">'123'</span>)</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(sy) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(sy2) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>
<h3 id="内置-Symbol-值"><a href="#内置-Symbol-值" class="headerlink" title="内置 Symbol 值"></a>内置 Symbol 值</h3><p>js 有一些行为一直是编译器内部在控制，代码无法影响的。而现在 js 通过一些预先定义好的 Symbol 属性将其暴露了出来。</p>
<ol>
<li>Symbol.hasInstance</li>
<li>Symbol.isConcatSpreadable</li>
<li>Symbol.iterator</li>
<li>Symbol.species</li>
<li>Symbol.toPrimitive</li>
<li>Symbol.toStringTag</li>
<li>Symbol.match</li>
<li>Symbol.search</li>
<li>Symbol.replace</li>
<li>Symbol.split</li>
<li>Symbol.unscopables</li>
</ol>
<h5 id="Symbol-hasInstance"><a href="#Symbol-hasInstance" class="headerlink" title="Symbol.hasInstance"></a>Symbol.hasInstance</h5><p>用于<code>a instanceof Func</code>时，此时会调用<code>Func[Symbol.hasInstance]</code>方法，方法的返回值就是<code>instanceof</code>的结果。<code>Symbol.hasInstance</code>定义在<code>Function.prototype</code>上，是一个不可遍历，不可修改，不可配置的属性。要修改<code>instanceof</code>默认行为需要使用如下方式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Name</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Name, <span class="built_in">Symbol</span>.hasInstance, &#123;</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，由于不可写属性的限制，不能采用如下方式</span></span><br><span class="line">Name[<span class="built_in">Symbol</span>.hasInstance] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Symbol-isConcatSpreadable"><a href="#Symbol-isConcatSpreadable" class="headerlink" title="Symbol.isConcatSpreadable"></a>Symbol.isConcatSpreadable</h5><p>调用<code>arr.concat(obj)</code>方法时，如果<code>obj</code>的<code>Symbol.isConcatSpreadable</code>为<code>true</code>，那么<code>obj</code>的前<code>length</code>个数字属性会被添加到<code>arr</code>中，非数字属性则会被丢弃。如果是<code>false</code>，<code>obj</code>会被直接添加到<code>arr</code>中。<br>注意：数字属性只会取<code>0 - length-1</code></p>
<p>默认情况下，任何对象都没有<code>Symbol.isConcatSpreadable</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    obj = &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">4</span>,</span><br><span class="line">        <span class="number">3</span>: <span class="number">5</span>,</span><br><span class="line">        a: <span class="string">'xiaogou'</span>,</span><br><span class="line">        length: <span class="number">2</span>,</span><br><span class="line">        [<span class="built_in">Symbol</span>.isConcatSpreadable]: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">arr.concat(obj) <span class="comment">// [1,2,3,4,empty]</span></span><br></pre></td></tr></table></figure>
<h5 id="Symbol-iterator"><a href="#Symbol-iterator" class="headerlink" title="Symbol.iterator"></a>Symbol.iterator</h5><p>用于<code>for...of</code>循环。可迭代对象都包含这个属性。<br><code>Symbol.iterator</code>是一个函数，需要返回一个<code>迭代器</code>。关于什么是迭代器，详见迭代器与生成器。<br>简单讲，迭代器就是包含<code>next()</code>方法属性的对象，每次调用<code>next()</code>方法时，都会返回一个<code>{value,done}</code>的对象,当<code>done</code>为 true 时，迭代器终止。</p>
<p><code>for...of</code>遍历时，实际上是遍历<code>Symbol.iterator()</code>返回的迭代器。</p>
<p>对象不可迭代的普通对象，可以通过添加<code>Symbol.iterator</code>方法来使其可以迭代。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            next() &#123;</span><br><span class="line">                <span class="keyword">if</span> (i++ &lt; 3) &#123;</span><br><span class="line">                    return &#123; value: i, done: false &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return &#123; done: true &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">for (let i of obj) &#123;</span><br><span class="line">    console.log(i)</span><br><span class="line">&#125;</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br><span class="line">// 4</span><br></pre></td></tr></table></figure>
<p>普通对象原本是不可以用于<code>for...of</code>循环的，通过添加<code>Symbol.iteraotr</code>方法，可使其可以通过<code>for...of</code>循环遍历。同理也可以用于数组的展开运算符。</p>
<p>虽然上例中使用的是普通函数，但是更普遍的做法可能是为<code>Symbol.iterator</code>函数赋一个生成器函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然形式不一样，但是与<code>Symbol.iterator</code>关系不大，主要还是生成器。这里就不展开了。</p>
<h5 id="Symbol-species"><a href="#Symbol-species" class="headerlink" title="Symbol.species"></a>Symbol.species</h5><p>内建对象实例方法返回新的实例时使用。比如 Array 的<code>slice</code>方法会返回一个新的 Array，如果通过 es6 extends 继承 Array，slice 方法会默认返回子类型的实例。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> MyArray(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),</span><br><span class="line">    b = a.slice(<span class="number">1</span>)</span><br><span class="line">b <span class="keyword">instanceof</span> MyArray <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>因为Array的<code>Symbol.species</code>默认指向this，所以返回MyArray类型的实例。<br>注意:<code>Symbol.species</code>定义为Array的静态属性，所以this指向实例的构造函数本身</p>
<p>通过指定<code>Symbol.species</code>可以返回一个其他类型的实例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species] ()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span> <span class="comment">// 也可以指定为其他值，比如MyClass</span></span><br><span class="line">    &#125;</span><br><span class="line">    clone()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">this</span>.constructor[<span class="built_in">Symbol</span>.species]()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用<code>Symbol.species</code>的内建类型有 Array, ArrayBuffer, Map, Set, Typed arrays, Promise, RegExp</p>
<h5 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a>Symbol.toPrimitive</h5><p>用于变量的类型转换。在做类型转换或者获取对象的原始值时，会调用此方法。如<code>&#39;&#39;+a</code>会调用<code>a</code>的<code>Symbol[toPrimitive]</code>方法。</p>
<p>方法接受一个参数<code>hint</code>，可能的值有<code>string、number、default</code>。表示当前转换采用的模式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.toPrimitive]: <span class="function"><span class="keyword">function</span>(<span class="params">hint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (hint) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'string'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">'string'</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'number'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">'number'</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'default'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">'default'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然可以为<code>string、number、default</code>指定不同的返回值，但是一般还是给<code>default</code>指定为<code>string、number</code>中的一个<br><code>string</code>与<code>number</code>模式比较好理解,<code>default</code>模式只会出现在下列三种情况</p>
<ol>
<li>==</li>
<li>+号运算符</li>
<li>给 Date 构造函数传递一个参数</li>
</ol>
<h5 id="Symbol-toStringTag"><a href="#Symbol-toStringTag" class="headerlink" title="Symbol.toStringTag"></a>Symbol.toStringTag</h5><p>js 中一直有一个识别类型的方法<code>Object.prototype.toString.call(obj)</code>，返回值<code>[object XXX]</code>，对于不同类型的对象,<code>XXX</code>各有不同。对于<code>Array</code>是<code>Array</code>，对于自定义对象，是<code>Object</code>。而<code>XXX</code>可以通过<code>Symbol.toStringTag</code>修改。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">name.prototype[<span class="built_in">Symbol</span>.toStringTag] = <span class="string">'name'</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> name())</span><br></pre></td></tr></table></figure>
<p>没错,<code>Symbol.toStringTag</code>的值是一个字符串，<strong>不是函数</strong></p>
<h5 id="Symbol-search"><a href="#Symbol-search" class="headerlink" title="Symbol.search"></a>Symbol.search</h5><p><code>Symbol.search、Symbol.match</code>等四个方法都是定义在<code>Regrex.prototype</code>上，是调用字符串方法<code>str.search(regex)、str.match(regex)</code>时调用的方法,所以<code>str.search(regex)</code>实际上调用的是<code>regex[Symbol.search](str)</code></p>
<p>这 4 个方法都接受字符串作为参数。<br>实际上，完全可以为一个对象定义这四个方法，然后当做正则表达式使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.search]: <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">'123'</span>.search(obj) <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Zhen Huang">
            
              <p class="site-author-name" itemprop="name">Zhen Huang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">博客</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhen Huang</span>
  <div class="powered-by">
    <i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
      本站访客数:<span id="busuanzi_value_site_uv"></span>
    </span>
  </div>
  
</div>



        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
