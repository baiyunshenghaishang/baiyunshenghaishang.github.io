<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="bai">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="bai">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="bai">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>bai</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
    <a href="https://github.com/baiyunshenghaishang"><img style="position:absolute;top:0;right:0" width="149" height="149" src="https://github.blog/wp-content/uploads/2008/12/forkme_right_gray_6d6d6d.png?resize=149%2C149" class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">bai</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/09/basis/execution/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhen Huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/09/basis/execution/" itemprop="url">js 执行过程概述</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-09T20:01:01+08:00">
                2019-09-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>js 的执行过程是一个很庞大的话题。要回答这样一个问题，可以从另外一个角度去思考。如果想要实现 js 引擎，应该如何实现。</p>
<p>考虑到 js 是单线程执行，理论上应该会比较简单。将传递给执行引擎的代码顺序执行即可。 so easy.</p>
<p>执行完成之后引擎是不是就可以洗洗睡了呢。然而并不能，因为实际情况中，还可能有事件、setTimeout 等过一段时间执行的代码，所以 js 引擎必须常驻内存中，等待着下一段要执行的代码。</p>
<p>可以用代码表示如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    execute(code)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简单，就是简单的循环判断。当然，实际情况会复杂很多，比如需要判断是否有代码需要执行。</p>
<p>在 js 中，我们将这样一个过程叫做事件循环。</p>
<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>此处讲的是浏览器中的事件循环，nodejs 中的事件循环更复杂一些，此处不讲。</p>
<p>事件循环就是一个不断循环，执行代码的过程。每一次循环过程中执行的代码称为一个宏任务。<br>所以事件循环就是不断循环执行宏任务的过程。</p>
<p>诸如 setTimeout、事件回调的代码，都会生成一个新的宏任务。</p>
<p>如果我们把多个宏任务理解为一个宏任务的队列，那么事件循环就是不断执行宏任务队列的过程。</p>
<p>一个宏任务中还可能包含多个微任务。微任务是 Promise 的 then 回调生成的任务。每次 then 的回调都会在当前宏任务的末尾增加一个微任务。</p>
<p>一个宏任务可以包含多个微任务。在执行下一个宏任务之前，执行引擎会先将当前宏任务的所有微任务执行完成。</p>
<p>所以虽然 Promise 和 setTimeout 生成的都是异步代码，但是其执行顺序是不同的。看以下代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"timeout"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"promise"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"sync code"</span>)</span><br><span class="line"><span class="comment">// sync code</span></span><br><span class="line"><span class="comment">// promise</span></span><br><span class="line"><span class="comment">// timeout</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>console.log(&quot;promise&quot;)</code>一定会在<code>console.log(&quot;timeout&quot;)</code>之前执行。因为 Promise 的 then 回调是在当前宏任务中末尾增加一个微任务，而 setTimeout 会生成一个新的宏任务。在执行新的宏任务执行，会先将当前宏任务中的所有微任务执行完成。</p>
<h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>在每一个宏任务/微任务中，执行的都是一段段的代码。</p>
<p>每一段代码的执行都需要一个环境，包含代码执行所需的所有条件。在 js 中，这个环境叫做执行上下文(execution context)。</p>
<h3 id="执行上下文的类别"><a href="#执行上下文的类别" class="headerlink" title="执行上下文的类别"></a>执行上下文的类别</h3><p>那什么样的代码能称之为一段代码呢。这样的说法可能不太准确，更准确的说法应该是。</p>
<p>什么样的代码会生成新的执行上下文呢?</p>
<p>在 js 中，只有三种执行上下文。所以也只有在这三种情况下会生成新的执行上下文。</p>
<ol>
<li>全局执行上下文</li>
<li>函数执行上下文</li>
<li>eval 执行上下文</li>
</ol>
<p>全局执行上下文只有一个，在 js 引擎生成时就会生成。<br>函数执行上下文在执行新的函数时生成。<br>eval 执行上下文在执行 eval 时生成</p>
<p>三种执行上下文概念上大体类似，细节处稍有不同，具体细节在讲到执行上下文组成部分时讲解。</p>
<h4 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h4><p>在代码的执行过程中，并不是只有一个执行上下文生成。而是伴随执行的过程不断生成新的执行上下文、销毁旧的执行上下文。</p>
<p>多个执行上下文需要一个结构来保存，这就是执行栈。</p>
<p>执行栈用于保存所有的执行上下文。</p>
<p>执行栈是一个典型的栈结构。即后进入栈的执行上下文先出栈。<br>生成新的执行上下文生成时会入栈，代码执行完成后当前执行上下文出栈。</p>
<h4 id="执行上下文的内容"><a href="#执行上下文的内容" class="headerlink" title="执行上下文的内容"></a>执行上下文的内容</h4><p>前面讲到，执行上下文包含了代码执行所需的所有条件，那么执行上下文到底包含了那些内容呢。<br>执行上下文的内容在 js 的各个版本中经历了比较大的变化。下面将讲述各个版本的执行上下文</p>
<h5 id="es3-中的执行上下文"><a href="#es3-中的执行上下文" class="headerlink" title="es3 中的执行上下文"></a>es3 中的执行上下文</h5><p>在 es3 时期，执行上下文包含三个部分: this、变量对象(VO)、作用域链(Scope)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从理解角度我们可以这样认为</span></span><br><span class="line">Execution Context = &#123;</span><br><span class="line">    <span class="keyword">this</span>,</span><br><span class="line">    VO,</span><br><span class="line">    Scope</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="this"><a href="#this" class="headerlink" title="this"></a>this</h6><p>this 是执行上下文的一部分，this 的指向也是一个比较复杂的话题，这里不展开。因为 this 的指向和执行过程的关系不大。</p>
<h6 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h6><p>代码在执行时会定义一些变量，这些变量都定义在变量对象中。<br>变量对象包含了在当前执行上下文中声明的所有变量。</p>
<p>以函数执行上下文为例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">talk</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">say()</span><br></pre></td></tr></table></figure>
<p>上面的函数 say 形成的执行上下文中变量对象可以用如下的代码表示</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vo = &#123;</span><br><span class="line">    x,</span><br><span class="line">    y,</span><br><span class="line">    <span class="built_in">arguments</span>,</span><br><span class="line">    talk</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的例子看到，函数 say 形成的执行上下文中包含了 say 中声明的所有变量和函数，也包含了没有声明的 arguments 变量，这也是可以在函数中直接访问 arguments 的原因。</p>
<p>在全局执行上下文中，变量对象就是全局上下文本身，也就是 window</p>
<p>在规范中，变量对象被定义为一个普通对象，其实这是个 bug，变量对象并不是普通对象，没有原型，所以变量查找不会沿着原型链上溯</p>
<h6 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h6><p>前面讲到，变量对象中存储了所有当前执行上下文中声明的变量（函数声明也是声明变量的一种方式）。<br>那么函数中如何访问变量呢，对于函数中定义的变量，可以通过变量对象访问。<br>但是函数中会访问函数中定义的变量，还会访问函数外定义的变量。</p>
<p>作用域(Scope)，也称为作用域链，用于控制执行上下文中所有变量的访问。</p>
<p>作用域是一个包含当前上下文和外部所有上下文变量对象的队列。<br>可以用如下代码表示</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scope = VO + [[Scope]]</span><br></pre></td></tr></table></figure>
<p><code>[[Scope]]</code>是一个函数的内部属性，在函数创建时生成，包含了所有函数外部执行上下文的变量对象。</p>
<p>[[Scope]] = [VO1,VO2,VO3,…]</p>
<p>[[Scope]]在函数创建时生成，在函数的生命周期中一直存在，这也是为什么闭包可以访问函数外部变量的原因。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> closure = <span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="number">4</span></span><br><span class="line">        <span class="built_in">console</span>.log(a + b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">closure()</span><br></pre></td></tr></table></figure>
<p>在执行函数 closure 时，函数 outer 的执行已结束，执行上下文也已出栈，但是 closure 仍然可以访问变量 a，因为函数 closure 的[[Scope]]属性会直接引用 outer 的变量对象。</p>
<h5 id="执行上下文的两个过程"><a href="#执行上下文的两个过程" class="headerlink" title="执行上下文的两个过程"></a>执行上下文的两个过程</h5><p>至此，已经讲完了 es3 中执行上下文的组成部分。<br>执行上下文的三部分，this 不讲，变量对象用于存储执行上下文中声明的变量，作用域用于执行上下文中访问变量时的查找。</p>
<p>但是关于变量的声明和查找，我们还需要更详细的讲解一下。</p>
<p>以函数执行上下文为例。<br>函数的执行过程包含两部分</p>
<ol>
<li>进入函数时</li>
<li>函数执行时</li>
</ol>
<p>对于语句<code>var a = 1</code>，对于 js 引擎而言，其实包含两部分</p>
<ol>
<li>var a，这是变量声明</li>
<li>a = 1 这是变量赋值</li>
</ol>
<p>其中变量声明在<strong>进入函数时</strong>进行，变量赋值在<strong>函数执行时</strong>进行。</p>
<p>进入函数时会执行以下过程</p>
<ol>
<li>声明 arguments 和函数声明的参数并赋值（对于非函数执行上下文没有这一步）</li>
<li>函数声明会声明函数同名变量并赋值，如果存在同名的变量，会覆盖</li>
<li>变量声明会被声明，并被赋值为 undefined，如果已存在同名变量，会跳过</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b, c) <span class="comment">// 1 ƒ b() &#123;&#125; 3 undefined</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">999</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b, c) <span class="comment">// 999 ƒ b() &#123;&#125; 3 888</span></span><br><span class="line">&#125;</span><br><span class="line">say(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<ol>
<li>上例中，变量 b 是函数的参数，同时也存在函数内部声明的函数 b，所以变量 b 被覆盖为函数 b。</li>
<li>而 a 因为函数内部声明的是变量，所以声明操作被跳过，所以值还是 1</li>
<li>c 没有同名变量，所以是 3 不变</li>
<li>d 是函数内部声明的变量，所以被声明，但是值是 undefined</li>
</ol>
<p>函数执行时</p>
<p>这个没什么好讲的，逐句代码执行</p>
<h5 id="es5-中的执行上下文"><a href="#es5-中的执行上下文" class="headerlink" title="es5 中的执行上下文"></a>es5 中的执行上下文</h5><p>es5 中的执行上下文同样包含三个部分</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">es5EC = &#123;</span><br><span class="line">    <span class="keyword">this</span>,</span><br><span class="line">    lexicalEnvironment, <span class="comment">// 词法作用域</span></span><br><span class="line">    variableEnvironment <span class="comment">// 变量作用域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>this 略过不讲。</p>
<p>其中词法作用域和变量作用域大部分时候是同一个对象，只在某些特殊的情况下，比如 with，两者会有不同，因为 with 已经不推荐使用，所以此处略过，大部分时候也不需要考虑两者之间的区别。</p>
<p>词法作用域(LexicalEnvironment)包含两部分</p>
<ol>
<li>环境记录，包含当前所有上下文声明所有变量的对象</li>
<li>outer，包含当前上下文的父级上下文的引用。对于全局上下文，这个值是 null</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">say(<span class="number">10</span>)</span><br><span class="line"><span class="comment">// 词法作用域和变量对象类似，同样包含两个阶段，此处是进入函数时</span></span><br><span class="line">say.LexicalEnvironment = &#123;</span><br><span class="line">    environmentRecord: &#123;</span><br><span class="line">        <span class="built_in">arguments</span>: &#123; xxx &#125;,</span><br><span class="line">        a: <span class="number">10</span>,</span><br><span class="line">        b: <span class="literal">undefined</span></span><br><span class="line">    &#125;,</span><br><span class="line">    outer: globalEnvironment</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与作用域类似，如果在当前环境记录中找不到变脸，则会继续查找当前词法作用域的父级词法作用域。<br>与作用域不同的是，词法作用域只包含父级词法作用域的引用</p>
<p>可以发现，词法作用域和变量对象/作用域链的概念非常类似，更多的是名词和实现的变化。而词法作用域概念的引入，主要是为了实现上的效率问题。</p>
<h5 id="es6-中的执行上下文"><a href="#es6-中的执行上下文" class="headerlink" title="es6 中的执行上下文"></a>es6 中的执行上下文</h5><p>es6 中的执行上下文没有找到比较好的文章，先放着吧。<br>唯一确定的两点</p>
<ol>
<li>this 放到了 lexicalEnvironment 中，而不是在执行上下文中</li>
<li>lexicalEnvironment 用于声明函数和 let/const，而 variableEnvironment 用于 var 的声明</li>
</ol>
<h3 id="语句的执行"><a href="#语句的执行" class="headerlink" title="语句的执行"></a>语句的执行</h3><p>代码执行，到最后都变为，在一定的环境（执行上下文）中执行代码。</p>
<p>所以代码执行的最后一部分是语句执行。</p>
<p>语句可以分为以下四类</p>
<ol>
<li>普通语句，包含声明语句、表达式语句等</li>
<li>语句块，即用大括号包裹的语句。</li>
<li>控制语句，包含 while/for/switch/break/continue 等</li>
<li>标签语句</li>
</ol>
<p>在语句的执行阶段，值得注意的只有控制语句。（声明语句虽然也有特殊之处，但是并不是在语句执行阶段）。</p>
<p>如果没有控制语句，所有语句都是顺序执行。控制语句，顾名思义，就是控制语句的执行顺序。</p>
<p>控制语句的控制效果可以见下图<br><img src="/images/语句执行.png" alt="控制语句"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/04/basis/asynciterator/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhen Huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/04/basis/asynciterator/" itemprop="url">异步迭代</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-04T19:04:27+08:00">
                2019-09-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h3><p>在<a href="https://baiyunshenghaishang.github.io/2019/03/25/basis/iterator/" target="_blank" rel="noopener">迭代器</a>中讲到了，<code>for...of</code>可以用来遍历可迭代对象，<br>相比于传统的 for 循环，<code>for...of</code>循环更加简洁</p>
<p><code>for...of</code>循环包含一个默认的约定，即可迭代对象的 next 方法必须是同步的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> generator())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item) <span class="comment">// 1 2 Promise对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，对于返回 Promise 对象可迭代对象，<code>for...of</code>循环并不能正确获取 Promise resolve 的值</p>
<h3 id="异步生成器"><a href="#异步生成器" class="headerlink" title="异步生成器"></a>异步生成器</h3><p>为了处理异步的迭代，js 增加了异步生成器和<code>for await ... of</code></p>
<p>下面是一个简单的异步生成器例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>* <span class="title">asyncGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(resolve, <span class="number">3000</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> gen = asyncGenerator()</span><br><span class="line">gen.next() <span class="comment">// Promise对象</span></span><br></pre></td></tr></table></figure>
<p>异步生成器是一个生成器函数，返回一个可迭代对象<br>但是不同于普通生成器返回的可迭代对象，异步生成器返回的可迭代对象每次调用 next 方法都会返回一个 Promise</p>
<h3 id="for-await-…of"><a href="#for-await-…of" class="headerlink" title="for await …of"></a>for await …of</h3><p>有了异步生成器，自然也需要异步迭代器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>* <span class="title">asyncGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(resolve, <span class="number">3000</span>))</span><br><span class="line">&#125;</span><br><span class="line">;(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> item <span class="keyword">of</span> asyncGenerator()) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(item) <span class="comment">// 1 2 undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>上面的例子中，<code>for await ... of</code>会先执行 next 方法，然后等待 next 方法返回的 Promise resolve,然后执行下一个 next 方法，然后等待下一个 Promise resolve，直到 next 方法返回 done：true</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/27/basis/async/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhen Huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/27/basis/async/" itemprop="url">异步函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-27T07:13:46+08:00">
                2019-08-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="为什么需要异步函数"><a href="#为什么需要异步函数" class="headerlink" title="为什么需要异步函数"></a>为什么需要异步函数</h3><p>异步函数时 js 新增的一种语法，用于异步的处理</p>
<p>js 中异步的处理经历了三个阶段</p>
<ol>
<li>回调函数</li>
<li>Promise</li>
<li>异步函数</li>
</ol>
<p>Promise 解决了很多回调函数的缺陷，比如回调地狱等，在回调函数的基础上前进了一大步</p>
<p>但是 Promise 并不完美，大量的 then 语法虽然结构上比回调函数清晰很多，但是同样令人眼花缭乱</p>
<p>所以我们需要一种更简洁的语法来表示异步编程，异步函数就是一种方案</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>异步函数也是一种函数，其声明方式和其它函数相同，唯一的区别是在 function 关键字之前需要加上 async 关键字，在异步函数内部可以使用 await 关键字。如果没有 function 关键字，需要在函数名之前加上 async 关键字</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> say = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="keyword">async</span> say() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>await 之后可以跟 Promsie 或者普通变量，如果是 Promise，异步函数会暂停执行，等待 Promise resolve 之后继续执行。await 的返回值就是 Promise 的决议值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pause = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">secs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(resolve, secs)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`paused <span class="subst">$&#123;secs&#125;</span> milsecs`</span>)</span><br><span class="line">&#125;</span><br><span class="line">pause(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure>
<p>上面的代码会在 3s 之后打印结果，这就是异步函数的最基本用法</p>
<p>异步函数会返回 Promise，如果异步函数执行报错，返回的 Promise 会执行 reject</p>
<h3 id="异步函数的错误处理"><a href="#异步函数的错误处理" class="headerlink" title="异步函数的错误处理"></a>异步函数的错误处理</h3><p>异步函数内部可以包含多个 await，任何 await 之后的 Promise reject 都会导致后续的 await 不会不行，异步函数返回的 Promise 会执行 reject</p>
<p>所以如果想某一个 await 之后的 Promise reject 之后继续执行，需要使用 catch 或者 try…catch</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> someThrowErrorPromise()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;&#125;</span><br><span class="line">    <span class="keyword">await</span> executePromiseAfterError()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> someThrowErrorPromise().catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">    <span class="keyword">await</span> executePromiseAfterError()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异步函数的模拟实现"><a href="#异步函数的模拟实现" class="headerlink" title="异步函数的模拟实现"></a>异步函数的模拟实现</h3><p>在生成器一章中讲到过，异步函数其实就是对生成器异步执行的一种标准化，所以完全可以用生成器来模拟异步函数。</p>
<p>当然，相比于生成器的模拟，异步函数的不需要执行器，而且语义更明确，所以还是推荐使用异步函数</p>
<p>在<a href="https://baiyunshenghaishang.github.io/2019/03/28/basis/generator/" target="_blank" rel="noopener">生成器</a>中已经详细讲解了如何模拟异步函数，这里只给出执行器的代码，其它的参考生成器一篇即可</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">tasks</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (result.done) <span class="keyword">return</span> resolve(result.value)</span><br><span class="line">            <span class="built_in">Promise</span>.resolve(result.value).then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">                step(gen.next(val))</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> gen = tasks(),</span><br><span class="line">            result = gen.next()</span><br><span class="line">        step(result)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>异步函数的出现是为了提供比 Promise 更简洁、语义更明确的异步代码。但是异步函数并不是完全取代 Promise，而是在 Promise 的基础上实现。从前面的代码中也可以看出，异步函数和 Promise 息息相关</p>
<p>所以并不是有了异步函数就不需要 Promise，我们仍然需要 Promise，只是在合适的地方，可以使用异步函数替代 Promise</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/15/engineer/code-quanlity/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhen Huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/15/engineer/code-quanlity/" itemprop="url">代码质量控制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-15T19:56:15+08:00">
                2019-08-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h3><p>关于代码质量问题的想法有段时间了，最开始考虑的是如何写出高质量的代码，拖来拖去最后不了了之。</p>
<p>前端时间看 eslint，考虑到可以使用 eslint 来保证提交代码的基本质量，于是就有了这篇文章。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>代码基本质量的控制，在我看来应该包含两部分</p>
<ol>
<li>代码格式，这部分主要是为了风格统一，以及防止意外的 git 冲突</li>
<li>代码基本质量，如声明的变量未使用这种低级错误</li>
</ol>
<p>第一点考虑使用 prettier 控制，第二点因为现在只有 js 的代码质量检测工具，使用 eslint</p>
<p>考虑到老项目的存在，选择 husky,lint-staged 在提交时检测修改的文件，否则在老项目添加 eslint 报错太多</p>
<p><strong>所以整体思路是在<code>git commit</code>前格式化所有文件，然后对 <code>.js,.vue,.jsx</code>文件执行 eslint 检测,如果 eslint 校验不通过，停止提交</strong></p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>配置包含三部分</p>
<ol>
<li>prettier 配置</li>
<li>eslint 配置</li>
<li>husky 和 lint-staged 配置</li>
</ol>
<h5 id="prettier-配置"><a href="#prettier-配置" class="headerlink" title="prettier 配置"></a>prettier 配置</h5><p>可参考 <a href="https://baiyunshenghaishang.github.io/2019/07/25/engineer/prettier/" target="_blank" rel="noopener">prettier 配置</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .prettierrc.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...require(<span class="string">"@baixiaogou/prettier-config"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑到打包后的文件都会在新增文件里面，所以需要增加<code>.prettierignore</code>，可以参考如下配置<br>node_modules 一般会在<code>.gitignore</code>中，所以不需要添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// .prettierignore</span><br><span class="line"></span><br><span class="line">dist</span><br><span class="line">**/*.min.*</span><br></pre></td></tr></table></figure>
<h5 id="eslint-配置"><a href="#eslint-配置" class="headerlink" title="eslint 配置"></a>eslint 配置</h5><p>可参考<a href="https://baiyunshenghaishang.github.io/2019/07/04/engineer/eslint/" target="_blank" rel="noopener">eslint 配置</a></p>
<p>注意，老项目不建议开启 eslint-loader，因为 eslint-loader 会检测全部代码，如果开启 eslint-loader，虽然提交时能通过校验，但是项目启动时会有很多报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .eslintrc.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    root: <span class="literal">true</span>,</span><br><span class="line">    parserOptions: &#123;</span><br><span class="line">        parser: <span class="string">"babel-eslint"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    parserOptions: &#123;</span><br><span class="line">        ecmaVersion: <span class="number">6</span>,</span><br><span class="line">        sourceType: <span class="string">"module"</span>,</span><br><span class="line">        ecmaFeatures: &#123;</span><br><span class="line">            jsx: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    env: &#123;</span><br><span class="line">        browser: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [<span class="string">"prettier"</span>, <span class="string">"html"</span>, <span class="string">"vue"</span>],</span><br><span class="line">    extends: [<span class="string">"eslint:recommended"</span>, <span class="string">"plugin:vue/recommended"</span>, <span class="string">"prettier"</span>],</span><br><span class="line">    rules: &#123;</span><br><span class="line">        <span class="string">"prettier/prettier"</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="husky-lint-staged-配置"><a href="#husky-lint-staged-配置" class="headerlink" title="husky/lint-staged 配置"></a>husky/lint-staged 配置</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// package.json</span><br><span class="line"> "husky": &#123;</span><br><span class="line">    "hooks": &#123;</span><br><span class="line">      "pre-commit": "lint-staged"</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  "lint-staged": &#123;</span><br><span class="line">    "src/*": [</span><br><span class="line">      "prettier --write",</span><br><span class="line">      <span class="string">"git add"</span></span><br><span class="line">    ],</span><br><span class="line">    "src/**/*.&#123;js,vue&#125;": [</span><br><span class="line">      "eslint",</span><br><span class="line">      <span class="string">"git add"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/12/basis/proto/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhen Huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/12/basis/proto/" itemprop="url">面向对象、原型、原型链、prototype</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-12T11:26:28+08:00">
                2019-08-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>初学 JS 的人可能会有疑惑，JS 到底是不是一门面向对象语言。如果是，为什么 JS 的什么原型好像与其它面向对象语言，如 Java、C++相去甚远。如果说不是，JS 标准中又明确提到了 JS 是一门面向对象语言.</p>
<blockquote>
<p>ECMAScript is an object-oriented programming language for performing computations and manipulating computational objects within a host environment.</p>
</blockquote>
<p>那么先回到最原始的问题，什么是面向对象</p>
<h5 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h5><p>面向对象是一种编程思想，即以对象作为程序基本单元的思想。</p>
<p>对象一词在英文中是<code>object</code>，指代一切事物。但是由于翻译的原因，中文中很难体现出这层意思。</p>
<p>对象的灵感来源于生活，面向对象也是。比如，在生活中，我们看到一只猫，只会想到一只猫。但是我们见识到各种各样的猫之后，逐渐会认识到猫这个类型。你会发现，这和面向对象中的类型和实例非常相似。</p>
<p>那如何定义对象呢，Grady Booch 在《面向对象程序与设计》一书中对对象的定义中描述了三个基本特征</p>
<ol>
<li>对象具有唯一标识性</li>
<li>对象具有状态</li>
<li>对象具有行为</li>
</ol>
<p>现有的面向对象语言中，对象的区分一般使用内存地址，从而做到即使看上去完全一样的对象，实际上也是不相等的，JS 也是如此。<br>而对象具有状态和行为，在 JS 中对应普通属性和函数类型的属性，在其它面向对象语言中的叫法则各不相同，例如 Java 中好像叫属性和方法。</p>
<p>以此看来，JS 完全是正统的面向对象语言，那么为什么我们会觉得 JS 和其它流行的面向对象语言差别很大呢。<br>这就在于 JS 的面向对象和其它面向对象语言的不同之处</p>
<h3 id="JS-的面向对象实现"><a href="#JS-的面向对象实现" class="headerlink" title="JS 的面向对象实现"></a>JS 的面向对象实现</h3><p>JS 的对象的特殊之处有两点</p>
<ol>
<li>JS 的对象的属性具有动态性。</li>
<li>JS 的使用原型链而不是 class 来实现面向对象的继承</li>
</ol>
<p>在 Java 等语言中，总是先有类型后有对象，对象创建之后，其拥有的属性数量是不可变的。<br>JS 不同，JS 中对象创建之后可以随便增加和删除属性。</p>
<h5 id="原型、原型链"><a href="#原型、原型链" class="headerlink" title="原型、原型链"></a>原型、原型链</h5><p>JS 中的原型其实非常简单，两句话就可以讲清楚</p>
<ol>
<li>每个对象都有<code>[[prototype]]</code>属性</li>
<li>在对象上找不到的属性，会沿着<code>[[prototype]]</code>继续寻找</li>
</ol>
<p>而每个对象的原型本身也是也是一个对象，也会有<code>[[prototype]]</code>属性，这就形成了原型的链条，即原型链</p>
<p>注意<code>[[prototype]]</code>是对象的内置属性，不是函数的<code>prototype</code>属性，正常情况下是无法在浏览器中查看该属性的，有些浏览器会以属性名<code>__proto__</code>暴露这个内置属性</p>
<p>这两点从 JS 创建以来几乎就没有变过，唯一不太确认的地方是<code>Object.create(null)</code>创建的对象是否有<code>[[prototype]]</code>属性，估计可能也有，只不过是 null</p>
<p>在 Java 等语言中，继承是方式是通过 class 继承。而在 JS 中，以一个对象为原型创建新的对象就可以实现对某个对象的继承</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> parent = &#123;</span><br><span class="line">    name: <span class="string">"爸爸"</span>,</span><br><span class="line">    say() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`我是你<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> son = <span class="built_in">Object</span>.create(parent)</span><br><span class="line">son.name = <span class="string">"儿子"</span></span><br><span class="line">son.say() <span class="comment">// 我是你儿子</span></span><br></pre></td></tr></table></figure>
<p>如上所示，JS 中的继承是通过原型和原型链实现，继承一个对象只需要以原有对象为原型创建一个新对象即可</p>
<p>讲到这儿，似乎 JS 的面向对象就讲完了。但是我们讲到 JS 的面向对象和继承，总是会讲到<code>prototype、new、class</code>等，那这些在 JS 的面向对象中又是什么关系呢</p>
<h3 id="prototype、class"><a href="#prototype、class" class="headerlink" title="prototype、class"></a>prototype、class</h3><p>在前面的面向对象中讲到了面向对象的三个基本特征，但是面向对象并没有规定应该如何实现。</p>
<p>很明显，现如今最流行最成功的方式是通过类的方式来实现面向对象。即先创建类型<code>class</code>，然后通过<code>new class</code>的方式来创建对象。</p>
<p>现在流行的面向对象语言，Java/C++都是这种方式，这也导致我们经常认为，这就是面向对象的基本特征之一。而这其实仅仅只是面向对象的实现方式之一。</p>
<p>除此之外，还有其他实现面向对象的方式。比如 JS 采用的原型链方式，也是一种不错的实现面向对象的方式。</p>
<p><code>prototype、new、class</code>是 JS 用来模拟类的方式实现面向对象的方法。</p>
<h5 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h5><p>为了模拟 Java 中的 class 的类属性和方法，JS 给函数增加了<code>prototype</code><br>为了模拟 class 的 new 操作，JS 给函数增加了<code>[[Constructor]]</code>方法</p>
<p>使用<code>new function</code>的方式可以创建一个新的对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"爸爸"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Parent()</span><br><span class="line"><span class="built_in">console</span>.log(p.name) <span class="comment">// 爸爸</span></span><br></pre></td></tr></table></figure>
<p>对于当做构造函数使用的函数，我们经常将首字母大写，但这只是一种约定，并没有任何运行上的区别。</p>
<p><code>new</code>操作实际上包含三步</p>
<ol>
<li>以当前函数的<code>prototype</code>属性为原型创建对象</li>
<li>以上一步创建的对象为<code>this</code>执行当前函数的<code>[[Contructor]]</code>方法</li>
<li>如果上一步的<code>[[Constructor]]</code>方法返回一个对象，返回改对象，否则返回第一步创建的对象</li>
</ol>
<p>JS 通过函数的<code>prototype</code>属性和<code>[[Constructor]]</code>模拟了 class 方式面向对象的构造函数和<code>new</code>操作，但是对于继承，直到<code>es6</code>之前，都没有官方的模拟方式</p>
<h5 id="class"><a href="#class" class="headerlink" title="class"></a>class</h5><p>在 es6 之前，class 一直都只是一个内部属性，唯一访问的方式是通过<code>Object.prototype.toString</code>访问。<br>这也是通过<code>Object.prototype.toString</code>能判断对象类型的原因</p>
<p>在 es6 中，JS 引入了原生的 class 实现，虽然也是使用原型来模拟，但是封装了很多容易出现的错误，而且语言加入了内置的<code>extends</code>关键字支持</p>
<p>关于 class 的具体细节，已经另外写了<a href="https://baiyunshenghaishang.github.io/2019/05/05/basis/class/" target="_blank" rel="noopener">一篇博客</a>，这里就不赘述了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/26/basis/object-classify/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhen Huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/26/basis/object-classify/" itemprop="url">对象分类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-26T07:11:20+08:00">
                2019-07-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="对象分类"><a href="#对象分类" class="headerlink" title="对象分类"></a>对象分类</h3><p>js 中的对象是数据结构中最复杂的一种。对象的类型包括两种</p>
<ol>
<li>宿主对象。 由 JavaScript 宿主提供的对象，最常见的是浏览器。如 history。不同的宿主环境中，这些对象不同。</li>
<li>内置对象。 JavaScript 语言提供的对象。</li>
</ol>
<p>其中内置对象又包含三种：</p>
<ol>
<li>固有对象。标准规定，随着 JavaScript 运行时而自动创建的对象。如 Array 构造函数</li>
<li>原生对象。用户通过 Array、RegExp 等内置构造器或特殊语法创建的对象</li>
<li>普通对象。由{}、Object 或 class 等创建的对象。</li>
</ol>
<h3 id="宿主对象"><a href="#宿主对象" class="headerlink" title="宿主对象"></a>宿主对象</h3><p>在浏览器中，最顶层的宿主对象是 window。浏览器中的宿主对象千奇百怪，这里不详细介绍。后续介绍浏览器 API 时会介绍。</p>
<p>浏览器中还包含用户创建的宿主对象，如通过<code>document.createElement</code>创建的对象。</p>
<h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><h5 id="固有对象"><a href="#固有对象" class="headerlink" title="固有对象"></a>固有对象</h5><p>固有对象是随着 JavaScript 运行时的创建而创建，在任何 JavaScript 代码执行之前就已经存在。<br>JavaScript 中的所有固有对象可以通过以下代码获取</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [</span><br><span class="line">        <span class="built_in">eval</span>,</span><br><span class="line">        <span class="built_in">isFinite</span>,</span><br><span class="line">        <span class="built_in">isNaN</span>,</span><br><span class="line">        <span class="built_in">parseFloat</span>,</span><br><span class="line">        <span class="built_in">parseInt</span>,</span><br><span class="line">        <span class="built_in">decodeURI</span>,</span><br><span class="line">        <span class="built_in">decodeURIComponent</span>,</span><br><span class="line">        <span class="built_in">encodeURI</span>,</span><br><span class="line">        <span class="built_in">encodeURIComponent</span>,</span><br><span class="line">        <span class="built_in">Array</span>,</span><br><span class="line">        <span class="built_in">Date</span>,</span><br><span class="line">        <span class="built_in">RegExp</span>,</span><br><span class="line">        <span class="built_in">Promise</span>,</span><br><span class="line">        <span class="built_in">Proxy</span>,</span><br><span class="line">        <span class="built_in">Map</span>,</span><br><span class="line">        <span class="built_in">WeakMap</span>,</span><br><span class="line">        <span class="built_in">Set</span>,</span><br><span class="line">        <span class="built_in">WeakSet</span>,</span><br><span class="line">        <span class="built_in">Function</span>,</span><br><span class="line">        <span class="built_in">Boolean</span>,</span><br><span class="line">        <span class="built_in">String</span>,</span><br><span class="line">        <span class="built_in">Number</span>,</span><br><span class="line">        <span class="built_in">Symbol</span>,</span><br><span class="line">        <span class="built_in">Object</span>,</span><br><span class="line">        <span class="built_in">Error</span>,</span><br><span class="line">        <span class="built_in">EvalError</span>,</span><br><span class="line">        <span class="built_in">RangeError</span>,</span><br><span class="line">        <span class="built_in">ReferenceError</span>,</span><br><span class="line">        <span class="built_in">SyntaxError</span>,</span><br><span class="line">        <span class="built_in">TypeError</span>,</span><br><span class="line">        <span class="built_in">URIError</span>,</span><br><span class="line">        <span class="built_in">ArrayBuffer</span>,</span><br><span class="line">        SharedArrayBuffer,</span><br><span class="line">        <span class="built_in">DataView</span>,</span><br><span class="line">        <span class="built_in">Float32Array</span>,</span><br><span class="line">        <span class="built_in">Float64Array</span>,</span><br><span class="line">        <span class="built_in">Int8Array</span>,</span><br><span class="line">        <span class="built_in">Int16Array</span>,</span><br><span class="line">        <span class="built_in">Int32Array</span>,</span><br><span class="line">        <span class="built_in">Uint8Array</span>,</span><br><span class="line">        <span class="built_in">Uint16Array</span>,</span><br><span class="line">        <span class="built_in">Uint32Array</span>,</span><br><span class="line">        <span class="built_in">Uint8ClampedArray</span>,</span><br><span class="line">        Atomics,</span><br><span class="line">        <span class="built_in">JSON</span>,</span><br><span class="line">        <span class="built_in">Math</span>,</span><br><span class="line">        <span class="built_in">Reflect</span></span><br><span class="line">    ],</span><br><span class="line">    set = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    set.add(item)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.getOwnPropertyNames(item)) &#123;</span><br><span class="line">        <span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(item, key)</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            (descriptor.value !== <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> descriptor.value === <span class="string">"object"</span>) ||</span><br><span class="line">            <span class="keyword">typeof</span> descriptor.value === <span class="string">"function"</span></span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.has(descriptor.value)) &#123;</span><br><span class="line">                arr.push(descriptor.value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (descriptor.get) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.has(descriptor.get)) &#123;</span><br><span class="line">                arr.push(descriptor.get)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (descriptor.set) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.has(descriptor.set)) &#123;</span><br><span class="line">                arr.push(descriptor.set)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(set)</span><br></pre></td></tr></table></figure>
<h5 id="原生对象"><a href="#原生对象" class="headerlink" title="原生对象"></a>原生对象</h5><p>原生对象是通过 JavaScript 内置的构造函数或特属于方式创建的对象，往往有着普通对象所没有的功能。比如由 Array 构造函数创建的数组，其 length 属性会随着长度自动变化，这是普通对象所不能模拟的。</p>
<p>JavaScript 中原生的构造函数包括以下这些</p>
<p>基本类型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> <span class="built_in">Number</span> <span class="built_in">Boolean</span> <span class="built_in">Symbol</span> <span class="built_in">Object</span></span><br></pre></td></tr></table></figure>
<p>数据结构</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span> <span class="built_in">Date</span> <span class="built_in">RegExp</span> <span class="built_in">Promise</span> <span class="built_in">Function</span></span><br><span class="line"><span class="built_in">Proxy</span> <span class="built_in">Map</span> <span class="built_in">Set</span> <span class="built_in">WeakMap</span> <span class="built_in">WeakSet</span></span><br></pre></td></tr></table></figure>
<p>错误类型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Error</span> <span class="built_in">EvalError</span> <span class="built_in">RangeError</span> <span class="built_in">ReferenceError</span> <span class="built_in">SyntaxError</span> <span class="built_in">TypeError</span> <span class="built_in">URIError</span></span><br></pre></td></tr></table></figure>
<p>二进制操作</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ArrayBuffer</span> SharedArrayBuffer <span class="built_in">DataView</span></span><br><span class="line"><span class="built_in">Float32Array</span> <span class="built_in">Float64Array</span> <span class="built_in">Int8Array</span> <span class="built_in">Int16Array</span> <span class="built_in">Int32Array</span> UInt8Array UInt16Array UInt32Array UInt8ClampedArray</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/25/engineer/prettier/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhen Huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/25/engineer/prettier/" itemprop="url">prettier</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-25T19:21:08+08:00">
                2019-07-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是-prettier"><a href="#什么是-prettier" class="headerlink" title="什么是 prettier"></a>什么是 prettier</h3><p>prettier 是一种代码格式化工具，支持 js、jsx、ts、css 等多种类型的语言</p>
<h3 id="why-prettier"><a href="#why-prettier" class="headerlink" title="why prettier"></a>why prettier</h3><p>prettier 的作用我认为有两点</p>
<ol>
<li>减少书写代码时控制代码格式的烦恼，一键就可以格式化</li>
<li>多人协作时保证代码格式一致。对于 git 而言这点很重要，否则对公共文件格式化，将会导致文件大范围改动，对合并代码是噩梦</li>
</ol>
<p>总结起来其实就一点，保证代码格式的统一。不管是个人代码格式的统一，还是项目代码格式的统一。</p>
<h3 id="prettier-vs-eslint"><a href="#prettier-vs-eslint" class="headerlink" title="prettier vs eslint"></a>prettier vs eslint</h3><p>eslint 提供了对于代码质量控制的检测，其规则包含两部分，代码格式和代码质量。<br>prettier 只包含了其中代码格式一部分。</p>
<p>eslint 其实算是 prettier 的超集，那为什么还需要 prettier 呢。</p>
<ol>
<li>eslint 的目的是代码质量控制，代码格式是质量控制的一部分，多人协作的项目中，代码格式尤为重要。但是代码格式控制的目的只是为了阅读体验和风格统一，书写代码时并不应该为代码格式费神。eslint 也有 fix 可以修复代码格式问题，但是 eslint 的 fix 并不能保证代码格式的统一，所以使用 prettier 更好。</li>
<li>prettier 不仅能够格式化 js 文件，还能够格式化 css 等文件，这些是 eslint 所不能处理的</li>
</ol>
<h3 id="cli"><a href="#cli" class="headerlink" title="cli"></a>cli</h3><p>prettier 的 cli 主要有两个<br><code>prettier --check [filename...]</code> 检测文件是否已经格式化，filename 的指定可以是文件名也可以是 glob 匹配<br><code>prettier --write [filename...]</code> 格式化文件<br>cli 方式会自动读取 prettier 配置文件</p>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>prettier 的 API 方式调用主要是<code>prettier.format</code>方法，API 方式并不会自动读取配置文件，所以需要查找配置文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是读取css文件并格式化写入的代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> prettier = <span class="built_in">require</span>(<span class="string">"prettier"</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>)</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">"util"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> filePath = <span class="string">"./test.css"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getPrettierStr</span>(<span class="params">filePath</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> fileStr = <span class="keyword">await</span> util.promisify(fs.readFile)(filePath, <span class="string">"utf-8"</span>)</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> prettier.getFileInfo(filePath)</span><br><span class="line">    <span class="keyword">const</span> parser = data.ignored ? <span class="literal">null</span> : data.inferredParser</span><br><span class="line">    <span class="keyword">if</span> (!parser) <span class="keyword">return</span> fileStr</span><br><span class="line">    <span class="keyword">const</span> config = <span class="keyword">await</span> prettier.resolveConfig(filePath)</span><br><span class="line">    <span class="keyword">const</span> formattedStr = <span class="keyword">await</span> prettier.format(fileStr, &#123; ...config, parser &#125;)</span><br><span class="line">    <span class="keyword">return</span> formattedStr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getPrettierStr(filePath).then(<span class="function"><span class="params">formattedStr</span> =&gt;</span> &#123;</span><br><span class="line">    fs.writeFile(filePath, formattedStr)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="prettier-配置"><a href="#prettier-配置" class="headerlink" title="prettier 配置"></a>prettier 配置</h3><p>prettier 的配置项并不多，而且也不建议使用太复杂的配置，我常用的配置如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .prettierrc.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    semi: <span class="literal">false</span>,</span><br><span class="line">    singleQuote: <span class="literal">true</span>,</span><br><span class="line">    endOfLine: <span class="string">"lf"</span>,</span><br><span class="line">    trailingComma: <span class="string">"none"</span>,</span><br><span class="line">    bracketSpacing: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以通过发布 npm 导出配置文件，这样可以直接引入配置文件。 <a href="https://www.npmjs.com/package/@baixiaogou/prettier-config" target="_blank" rel="noopener">@baixiaogou/prettier-config</a></p>
<p>使用方式如下:<br>在<code>package.json</code>中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"prettier"</span>: <span class="string">"@baixiogou/prettier-config"</span></span><br></pre></td></tr></table></figure>
<p>或者<br>使用<code>prettier</code>配置文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .pretterrc.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...require(<span class="string">"@baixiaogou/prettier-config"</span>)</span><br><span class="line">    <span class="comment">// 额外的覆盖配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="与-eslint-结合"><a href="#与-eslint-结合" class="headerlink" title="与 eslint 结合"></a>与 eslint 结合</h3><p>与 eslint 结合使用的思路是禁用 eslint 的格式化校验规则，然后开启 prettier 的规则校验</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .eslintrc.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  plugins: [<span class="string">'prettier'</span>],</span><br><span class="line">  extends: [<span class="string">'eslint:recommended'</span>, <span class="string">'prettier'</span>],</span><br><span class="line">  rules: &#123;</span><br><span class="line">    <span class="string">'prettier/prettier'</span>: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>eslint-plugin-prettier</code>增加<code>prettier/prettier</code>校验规则<br><code>eslint-config-prettier</code>去掉 eslint 中关于格式的校验，所以最好放在 extends 的最后防止被覆盖</p>
<p>这种方案只能用于 js 的校验和格式化。</p>
<h3 id="ignore"><a href="#ignore" class="headerlink" title="ignore"></a>ignore</h3><p>增加<code>.prettierignore</code>文件可以指定<code>prettier</code>不格式化的文件，在某些文件夹或者某些文件不格式化时非常有用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// .prettierignore</span><br><span class="line"></span><br><span class="line">node_modules</span><br><span class="line">dist</span><br><span class="line">**/*.min.*</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/04/engineer/eslint/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhen Huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/04/engineer/eslint/" itemprop="url">eslint</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-04T20:22:38+08:00">
                2019-07-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>eslint 简介</p>
<h3 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h3><p>eslint 是 2013 年由 Nicholas C. Zakas 发起的开源项目。目标是提供一个插件化的<b>JavaScript</b>代码检测工具。</p>
<p>eslint 的目的，个人认为是代码的质量控制。插件化是其实现方式。</p>
<p>代码的质量控制其实是一个比较大的话题，从更高的层面来看，组件化也是一种很重要的方式。<br>eslint 不能保证写出好的代码，但是 eslint 可以检测一些低级错误，比如使用未声明的变量、变量声明但是没有使用。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>esint 的配置项种类不多，大致包括以下几种</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    root: <span class="literal">true</span>, <span class="comment">// 标识eslint配置文件检测到此为止,不再往父目录查找</span></span><br><span class="line">    parserOption: &#123;</span><br><span class="line">        ecmaVersion: <span class="number">6</span>, <span class="comment">// 指定可用的ecma版本,</span></span><br><span class="line">        sourceType: <span class="string">"module"</span> <span class="comment">// 指定可用的文件类型，脚本还是模块</span></span><br><span class="line">    &#125;,</span><br><span class="line">    extends: [<span class="string">"eslint:recommended"</span>], <span class="comment">// 用于指定一组初始的规则，可以省略 eslint-config 前缀，必须是安装好的npm包</span></span><br><span class="line">    plugins: [<span class="string">"exmaple"</span>], <span class="comment">// 定义自定义的规则，可以省略eslint-plugin前缀，必须是安装好的npm包</span></span><br><span class="line">    rules: &#123;</span><br><span class="line">        <span class="comment">// 最主要的的配置项，用于指定规则的开启/关闭，以及错误等级</span></span><br><span class="line">        quotes: [<span class="string">"error"</span>, <span class="string">"double"</span>],</span><br><span class="line">        eqeqeq: [<span class="string">"off"</span>],</span><br><span class="line">        curly: [<span class="string">"warn"</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    env: &#123;</span><br><span class="line">        <span class="comment">// 指定环境，应该是某些全局变量使用不会被eslint报错</span></span><br><span class="line">        browser: <span class="literal">true</span>,</span><br><span class="line">        node: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    globals: &#123;</span><br><span class="line">        <span class="comment">// 指定额外的全局变量，false表示不能修改，true表示可以修改</span></span><br><span class="line">        _app_config: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整的配置项查看<a href="https://cn.eslint.org/docs/user-guide/configuring" target="_blank" rel="noopener">eslint 配置(官方)</a></p>
<p>eslint 配置主要是通过添加<code>plugin</code>增加额外的配置规则，通过<code>extends</code>添加默认的规则，然后通过<code>rules</code>增加或覆盖特殊的配置</p>
<p>eslint 默认全部规则在可以<a href="https://cn.eslint.org/docs/rules/" target="_blank" rel="noopener">在此查看</a></p>
<p>但是可以通过插件增加其他规则。如<code>eslint-plugin-import</code>增加导入/导出规则校验</p>
<p>除此之外，配置没有太多需要细究的地方</p>
<h3 id="常用插件配置"><a href="#常用插件配置" class="headerlink" title="常用插件配置"></a>常用插件配置</h3><p>下文中的插件均需要安装</p>
<h5 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h5><p>eslint 是 js 的检测工具，原本是不能检查.vue 文件的，想要检查.vue 文件，需要 eslint-plugin-vue 和 eslint-plugin-html</p>
<p>规则可以使用 <code>plugin:vue/recommended</code></p>
<h5 id="import-export"><a href="#import-export" class="headerlink" title="import/export"></a>import/export</h5><p>本插件可能不需要，import 提示应该通过编辑器插件来做，而 import 找不到 webpack 也会提示</p>
<p>eslint-plugin-import 插件可以检查引入的包或者文件是否存在<br>由于 import 受 webpack 的配置影响，import 插件可能无法正确判断引入路径是否正确，可以使用 eslint-import-resolver-webpack 来配置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .eslintrc.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    settings: &#123;</span><br><span class="line">        <span class="string">"import/resolver"</span>: &#123;</span><br><span class="line">            webpack: &#123;</span><br><span class="line">                config: <span class="string">"./build/webpack.dev.conf.js"</span> <span class="comment">// 指定要使用的 webpack 配置文件</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [<span class="string">"import"</span>],</span><br><span class="line">    extends: [<span class="string">"plugin:import/errors"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="prettier"><a href="#prettier" class="headerlink" title="prettier"></a>prettier</h5><p>eslint 本身有格式的校验，但是 eslint 本身只能校验 js 的格式，而且 eslint 的格式化配置不如 prettier 丰富</p>
<p>从另一个角度考虑，写代码时不应该太多考虑格式的问题，所以个人习惯是采用 prettier 格式化代码，eslint 只做格式化之外的校验</p>
<p>为此需要引入 eslint-plugin-prettier 插件，并继承 eslint-config-prettier 配置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [<span class="string">"prettier"</span>],</span><br><span class="line">    extends: [<span class="string">"prettier"</span>],</span><br><span class="line">    rules: &#123;</span><br><span class="line">        <span class="string">"prettier/prettier"</span>: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="eslint-loader"><a href="#eslint-loader" class="headerlink" title="eslint-loader"></a>eslint-loader</h5><p>如果想要代码书写时动态检查 js 代码，需要安装 eslint-loader<br>由于 babel 的关系，需要指定 eslint 的 parse 为 babel-eslint</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    parseOptions: &#123;</span><br><span class="line">        parse: <span class="string">"babel-eslint"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在webpack的配置文件中</span></span><br><span class="line">rules: [</span><br><span class="line">    &#123;</span><br><span class="line">        test: <span class="regexp">/\.(vue|js|jsx)$/</span>,</span><br><span class="line">        loader: <span class="string">"eslint-loader"</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        enforce: <span class="string">"pre"</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>一份常见的配置文件如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    root: <span class="literal">true</span>,</span><br><span class="line">    parserOptions: &#123;</span><br><span class="line">        parser: <span class="string">"babel-eslint"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    parserOptions: &#123;</span><br><span class="line">        ecmaVersion: <span class="number">6</span>,</span><br><span class="line">        sourceType: <span class="string">"module"</span>,</span><br><span class="line">        ecmaFeatures: &#123;</span><br><span class="line">            jsx: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    env: &#123;</span><br><span class="line">        browser: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    settings: &#123;</span><br><span class="line">        <span class="string">"import/resolver"</span>: &#123;</span><br><span class="line">            webpack: &#123;</span><br><span class="line">                config: <span class="string">"webpack.dev.config.js"</span> <span class="comment">// 指定要使用的 webpack 配置文件</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [<span class="string">"prettier"</span>, <span class="string">"import"</span>, <span class="string">"html"</span>, <span class="string">"vue"</span>],</span><br><span class="line">    extends: [<span class="string">"eslint:recommended"</span>, <span class="string">"prettier"</span>, <span class="string">"plugin:import/errors"</span>, <span class="string">"plugin:vue/recommended"</span>],</span><br><span class="line">    rules: &#123;</span><br><span class="line">        <span class="string">"prettier/prettier"</span>: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/03/basis/sytax/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhen Huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/03/basis/sytax/" itemprop="url">语法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-03T07:35:59+08:00">
                2019-07-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="js-语言的整体架构"><a href="#js-语言的整体架构" class="headerlink" title="js 语言的整体架构"></a>js 语言的整体架构</h3><p>js 包含两种源文件。一种是脚本，另一种是模块。<br>脚本就是普通的.js 文件，模块是 es6 引入的，与脚本只有一个区别，就是可以使用 export/import 语句。<br>使用模块需要在引入的 script 标签上加上<code>type=module</code>，否则文件会被认为是脚本而报错。模块和 import/export 的更详细了解<a href="https://baiyunshenghaishang.github.io/2019/05/22/basis/import_export/" target="_blank" rel="noopener">可以看这里</a></p>
<h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>import/export 之外的语句可以分为两种，一种是普通语句，另一种是预处理语句。<br>其中预处理语句在执行之前会有预处理过程，这是很多 js 执行结果让人感到奇怪的原因。<br>预处理的执行时间在代码执行之前，准确来讲应该在包含预处理代码的作用域的所有代码执行之前。每次进入一个新的作用域，执行代码之前都会先进行预处理</p>
<p>js 中会有预处理效果的语句包括</p>
<ol>
<li>var</li>
<li>function 声明</li>
<li>let/const/class 声明</li>
</ol>
<p>var 的预处理效果是在作用域内声明同名变量，但是并不会赋值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line">say()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a) <span class="comment">// undefined</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中，say 函数内部的 console.log(a)打印的是 undefined，因为 a 进行了预处理，在刚进入函数 say，执行 var a = 4 之前，a 就已经声明，但是没有赋值</p>
<p>function 声明的预处理效果是声明和赋值都会提升到作用域顶部，上面的例子中在 say 声明之前就之前了 say()，但不会报错，就是因为 function 声明会提升到作用域顶部。<br>注意：只有函数声明会被提升，函数表达式不会</p>
<p>let/const/class 的预处理效果是一样的。下面以 let 为例<br>let 会在作用域内，声明之前形成暂时性死区，此时对 let 声明变量的任何访问都会报错，包括 typeof</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">3</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">//  3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a) <span class="comment">// 报错</span></span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="普通语句"><a href="#普通语句" class="headerlink" title="普通语句"></a>普通语句</h3><p>预处理语句之外，普通语句包括以下这些类型</p>
<ol>
<li>空语句</li>
<li>语句块</li>
<li>表达式语句</li>
<li>循环语句</li>
<li>if 语句</li>
<li>switch/case 语句</li>
<li>try/catch 语句</li>
<li>throw 语句</li>
<li>debugger 御酒</li>
<li>return 语句</li>
<li>break 语句</li>
<li>continue 语句</li>
<li>with 语句</li>
</ol>
<p>其中循环语句和表达式语句比较复杂一点，其它语句没什么好讲的。<br>循环语句包括以下六种</p>
<ol>
<li>while</li>
<li>do/while</li>
<li>for</li>
<li>for/in</li>
<li>for/of</li>
<li>for/await of</li>
</ol>
<p>推荐尽可能使用 for/of 和 for/await of 语法</p>
<h3 id="表达式语句"><a href="#表达式语句" class="headerlink" title="表达式语句"></a>表达式语句</h3><p>表达式语句本身的分类比较多，也没有太多的必要去记住每一种分类。表达式语句的分类涉及到操作符的优先级，但是其实不建议使用特别复杂的优先级去写代码。用一个()代码会清晰明了很多。<br>因为操作符的优先级可能会出现微调，而且清晰明了的代码对维护者也是比较友好的。写代码的目的毕竟不是为了炫技。<br>实际代码中最有用的操作符优先级应该是<code>&amp;&amp; 》 || 》 ?:</code></p>
<p>表达式语句从大类上分为两种，左值表达式和条件表达式。左值表达式是可以出现在=左边的表达式，条件表达式是出现在=右边的表达式。左值表达式同时也是右值表达式。因为高优先级的表达式天然都是低优先级的表达式。<br>赋值表达式可以通过<code>,</code>运算符连接成表达式。但是实际上我们很少用逗号运算符，所以赋值表达式基本就是常用表达式的终极形态，也是优先级最低的表达式</p>
<h5 id="左值表达式"><a href="#左值表达式" class="headerlink" title="左值表达式"></a>左值表达式</h5><p>左值表达式优先级从高到低顺序如下</p>
<p>PrimaryExpression =&gt; MemberExpression =&gt; NewExpression/CallExpression =&gt; 左值表达式</p>
<p>PrimaryExpression: 直接量，包含字面量、变量。<br>任何表达式加上()都会变成 PrimaryExpression</p>
<p>MemberExpression: 成员表达式。<br>例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a.b</span><br><span class="line">a[b]</span><br><span class="line"><span class="keyword">super</span>.b</span><br><span class="line"><span class="keyword">this</span>.a</span><br><span class="line"><span class="keyword">new</span>.target</span><br><span class="line">say<span class="string">`abc`</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>有两种比较特殊的情况,跟字符串模板的函数和带参数列表的 NEW 表达式也是成员表达式，他们之间语义上并没有什么关联，放到一起只是因为优先级相同。</p>
<p>NewExpression/CallExpression: new 表达式和函数调用表达式。<br>例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line">a()</span><br><span class="line">a().b</span><br></pre></td></tr></table></figure>
<p>注意，不带参数列表的是 NewExpression，优先级比带参数列表的低。</p>
<p>可以看到，左值表达式的类型还是比较少的，大类上就只有 NEW 表达式和函数调用表达式两种。</p>
<h5 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h5><p>左值表达式也是条件表达式。所以左值表达式的优先级都比条件表达式高。<br>条件表达式的优先级从高到低如下<br>左值表达式 =&gt; updateExpression =&gt; unaryExpression/exponentiationExpression =&gt; MultiplicativeExpression =&gt; addtiveExpression<br>=&gt; shiftExpression =&gt; relationExpression =&gt; equalityExpression =&gt; 位运算表达式 =&gt; 逻辑与/或表达式 =&gt; 条件表达式</p>
<p>updateExpression 更新表达式<br>左值表达式加上自增++/自减–</p>
<p>unaryExpression 一元表达式<br>更新表达式搭配医院运算符，包括 +、-、typeof、delete、void、await、!、~</p>
<p>exponentiationExpression 乘方表达式<br>更新表达式搭配乘方运算符</p>
<p>MultiplicativeExpression 乘法表达式 * / %<br>addtiveExpression 加法表达式 + -<br>这个没什么好说的</p>
<p>shiftExpression 位移表达式<br>包括 &gt;&gt; &lt;&lt; &gt;&gt;&gt; 不太懂，最好也不要用<br>js 中使用这个并不能提高性能。</p>
<p>relationExpression 关系表达式<br>位移表达式和 &gt; &gt;= &lt; &lt;= instanceof in 构成关系表达式</p>
<p>equalityExpression 相等表达式<br>关系表达式和 == != === !== 构成，也没什么好讲的</p>
<p>位运算表达式<br>按位与、或、异或的表达式，不太了解。感觉也不太用的上</p>
<p>逻辑与/或表达式<br>位运算表达式和&amp;&amp; || 构成的表达式</p>
<p>条件表达式<br>逻辑与/或表达式御 ?: 构成的表达式</p>
<p>条件表达式就是的种类是比较多的，优先级的顺序也比较复杂。但是其实不需要是了解所有表达式的优先级。也不建议使用特别复杂的优先级顺序写代码。使用大家都熟悉、了解的优先级顺序，然后在需要的时候加括号是更好的习惯。毕竟操作符的优先级也是会发生变化的。</p>
<p>这是<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" target="_blank" rel="noopener">mdn 关于各种操作符优先级和结合性的表格</a>。不确定操作符的优先级时可以参考。<br>可以看到，操作符的优先级和表达式的优先级其实是一一对应的。</p>
<h3 id="自动分号插入"><a href="#自动分号插入" class="headerlink" title="自动分号插入"></a>自动分号插入</h3><p>js 在某些情况下会在语句尾部自动插入分号</p>
<ol>
<li>有换行符，且下一个符号是不符合语法的，自动插入分号</li>
<li>有换行符，语法明确规定不能有换行符的，自动插入分号</li>
<li>源代码结束处，不能形成完整的脚本或者模块，自动插入分号</li>
</ol>
<p>举个栗子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>3 后面跟 let 是不合法的语法，所以会自动插入换行符</p>
<p>第二点中，语法中规定不能有换行符的 no LineTerminator here 规则如下</p>
<ol>
<li>带标签的 continue/break 语法，后面不能有换行符</li>
<li>return 后面不能有换行符</li>
<li>后自增、后自减运算符前不能插入换行（注意此处不包括前自增、自减）</li>
<li>throw 和 Exception 之间不能插入换行</li>
<li>async 关键字后不能插入换行</li>
<li>箭头函数的箭头前，不能插入换行</li>
<li>yield 之后，不能插入换行</li>
</ol>
<p>on LineTerminator here 规则没有定义，可能会产生歧义的地方包括</p>
<ol>
<li>以括号开头的语句<br>主要是 IIFE</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;)()</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>上面的代码中第二个 IIFE 前没有分号，语法会认为前一个 IIFE 是一个函数，而第二个 IIFE 被认为是函数执行。从而导致抛出错误</p>
<ol start="2">
<li>以数组开头的语句</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">3</span></span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)].map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>let a = 3</code>之后没有换行符，<code>[1,2,3]</code>被认为是<code>MemberExpression</code>，对<code>3</code>的属性取值，<code>1,2,3</code>被认为是逗号连接的表达式，自然会抛出错误</p>
<ol start="3">
<li>以正则表达式开头的语句</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">3</span></span><br><span class="line">/abc/.test(<span class="string">'ac'</span>)</span><br></pre></td></tr></table></figure>
<p>3 之后的/会被认为是除法的一部分，这种情况在实际代码中比较少见</p>
<ol start="4">
<li>以模板字符串开头的语句</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">3</span></span><br><span class="line"><span class="string">`abc`</span>.match(<span class="regexp">/a/</span>)</span><br></pre></td></tr></table></figure>
<p>3 之后没有换行符，3`abc`被认为是函数之后跟模板字符串的函数执行。这种情况也比较少见</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/23/basis/lexical/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhen Huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/23/basis/lexical/" itemprop="url">词法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-23T19:02:02+08:00">
                2019-05-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>js 词法简介</p>
<h3 id="什么是词法"><a href="#什么是词法" class="headerlink" title="什么是词法"></a>什么是词法</h3><p>从浏览器执行的角度看，js 文件最先是通过网络从服务器上获取的，得到是一段二进制数据，然后浏览器根据对应的编码将这段二进制数据转换为字符串。<br>再将字符串拆分为有意义的词，一般称之为 token。token 是语言的最小语义单元。<br>词法规定了语言的 token 种类。</p>
<h3 id="词的分类"><a href="#词的分类" class="headerlink" title="词的分类"></a>词的分类</h3><p>js 中的词包括以下几种</p>
<ol>
<li>空白符</li>
<li>换行符</li>
<li>注释</li>
<li>标识符名称</li>
<li>符号</li>
<li>数字字面量</li>
<li>字符串字面量</li>
<li>字符串模板</li>
<li>正则表达式字面量</li>
</ol>
<p>下面分别讲述这几种不同的词</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>注释对于词法而言一般是无意义的，但是对 js 的语法的自动分号补全规则有影响。因为包含换行符的注释会被认为包含换行符，所以注释也是一种有效的词法。<br>除此之外，注释并没有特别的意义。</p>
<h3 id="空白符"><a href="#空白符" class="headerlink" title="空白符"></a>空白符</h3><p>js 支持 unicode 中的所有空白符，种类很多，下面介绍几种常用的</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">HT</td>
<td style="text-align:center">U+0009, \t 即常见的 tab 缩进</td>
</tr>
<tr>
<td style="text-align:center">VT</td>
<td style="text-align:center">\v 垂直缩进，比较少见</td>
</tr>
<tr>
<td style="text-align:center">FF</td>
<td style="text-align:center">分页符 \f</td>
</tr>
<tr>
<td style="text-align:center">SP</td>
<td style="text-align:center">U+0020, 常见的空格</td>
</tr>
<tr>
<td style="text-align:center">NBSP</td>
<td style="text-align:center">U+00a0, 非断行空格，html 中的<code>&amp;nbsp;</code>就是它</td>
</tr>
<tr>
<td style="text-align:center">ZWNBSP</td>
<td style="text-align:center">BOM，零宽非断行空格，常用于文件头部表示 utf 的编码方式</td>
</tr>
<tr>
<td style="text-align:center">ZWSP</td>
<td style="text-align:center">零宽空格</td>
</tr>
</tbody>
</table>
<p>其它空格参见<a href="https://zh.wikipedia.org/wiki/%E7%A9%BA%E6%A0%BC" target="_blank" rel="noopener">wiki-空格</a></p>
<p>一般而言，空格符对 js 的执行是没有影响的。但是字符串中可以包含零宽空格，会改变字符串的长度，也可以有一些有意思的应用。<br><a href="https://github.com/baiyunshenghaishang/zero-width-space" target="_blank" rel="noopener">零宽空格的一种应用</a></p>
<h3 id="换行符"><a href="#换行符" class="headerlink" title="换行符"></a>换行符</h3><p>不同于空格符，js 中只提供了 4 种换行符。<br>换行符对语法的影响也只存在于分号自动补全规则。</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">LF</td>
<td style="text-align:center">通常意义的换行符，\n</td>
</tr>
<tr>
<td style="text-align:center">CR</td>
<td style="text-align:center">回车，\r</td>
</tr>
<tr>
<td style="text-align:center">LS</td>
<td style="text-align:center">unicode 中的行分隔符</td>
</tr>
<tr>
<td style="text-align:center">PS</td>
<td style="text-align:center">unicode 中的段落分隔符</td>
</tr>
</tbody>
</table>
<h3 id="标识符名称"><a href="#标识符名称" class="headerlink" title="标识符名称"></a>标识符名称</h3><p>标识符名称包含变量名、关键字、保留字、true/false 和 null<br>其中变量名可以以 美元符号\$、下划线_或字母开始，还可以包含数字</p>
<p>关键字和保留字就不列举了<br>可以参见<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Lexical_grammar" target="_blank" rel="noopener">MDN 词法</a></p>
<h3 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h3><p>js 中的所有符号如下<br><code>{ ( ) [ ] . ... ; , &lt; &gt; &lt;= &gt;= == != === !== + - * % ** ++ -- &lt;&lt; &gt;&gt; &gt;&gt;&gt; &amp; | ^ ! ~ &amp;&amp; || ? : = += -= *= %= **= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;= &amp;= |= ^= =&gt; / /= }</code></p>
<h3 id="数字字面量"><a href="#数字字面量" class="headerlink" title="数字字面量"></a>数字字面量</h3><p>数字字面量包含 2 进制、8 进制、10 进制、16 进制 4 种形式<br>2 进制以 0b/0B 开头，数字不能超过 1，如<code>0b011101</code><br>8 进制以 0o/0O 开头，数字不能超过 7，如<code>0o12345667</code><br>10 进制就是我们常见的数字<br>16 进制以 0x/0X 开头，包含<code>0-9,A-F</code>，如<code>0xA32E</code>，也可以使用小写字母</p>
<p>其中只有10进制可以包含小数和使用科学计数法。</p>
<p>小数点前面和后面的数字都可以省略，如<code>10.</code>,<code>.03</code>都是有效的数字，但是不能同时省略。</p>
<p>小数点的优先级比属性获取要高，所以<code>10.toString</code>中的<code>.</code>会被认为是小数点，从而报词法错误。正确的使用方式应该是<code>10..toString</code></p>
<p>10进制的数字还可以使用科学计数法表示，如<code>3e6</code><br>也可以使用大写E,e之前可以使用小数，e之后只能使用整数，可以是负数，如<code>10.23E-3</code></p>
<h3 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h3><p>字符串可以使用单引号，也可以使用双引号。单引号字符串中双引号必须转义，双引号字符串中单引号必须转义，除此之外没有区别。<br>字符串除了字面量的表示，还支持 unicode 表示。</p>
<ol>
<li>使用 <code>\uXXXX</code>，表示基本平面的字符</li>
<li>使用<code>\u{XXXXXX}</code>表示</li>
</ol>
<p>字符串的转义<br>关于字符串的转义，包含两部分含义，</p>
<ol>
<li>有些字符在字符串中必须被转义，比如 \</li>
<li>有些字符连在一起之后表示另外一个字符的意思，比如\n</li>
</ol>
<p>字符串中必须被转义的字符只有<code>\</code>和换行符，因为换行符是没法在字符串中直接被表示的，空白符可以。</p>
<p>包含特殊意义的字符则包括以下这些<br><code>\&#39; \&quot; \\ \b \f \t \v \n \r</code><br>其中 <code>\b</code>表示退格符，删除前一个字符，其它的前面都已经讲到</p>
<p>还有几种包含特殊意义的组合<br>\数字 八进制表示的整数，表示一个字符，数字是unicode编码的8进制表示,如z是\172，最大255<br>\xXX 16进制表示的数字，表示一个字符，数字是unicode编码的16进制表示，最大255</p>
<p>\uXXXX 16进制表示的数字,表示一个unicode基本平面的字符<br>\u{XXXXXX} 16进制表示的数字，表示一个unicode字符</p>
<p>除此之外, \和其它字符组合都是字符本身。</p>
<h3 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h3><p>字符串模板和字符串基本类似。转义规则稍有不同，字符串模板中换行符<code>\n</code>是可以通过换行直接表示的，单双引号也可以直接使用。</p>
<h3 id="正则表达式字面量"><a href="#正则表达式字面量" class="headerlink" title="正则表达式字面量"></a>正则表达式字面量</h3><p>正则表达式比较复杂，会单独写一篇博客。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Zhen Huang">
            
              <p class="site-author-name" itemprop="name">Zhen Huang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">博客</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">42</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhen Huang</span>
  <div class="powered-by">
    <i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
      本站访客数:<span id="busuanzi_value_site_uv"></span>
    </span>
  </div>
  
</div>



        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
