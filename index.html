<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="bai">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="bai">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="bai">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>bai</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
    <a href="https://github.com/baiyunshenghaishang"><img style="position:absolute;top:0;right:0" width="149" height="149" src="https://github.blog/wp-content/uploads/2008/12/forkme_right_gray_6d6d6d.png?resize=149%2C149" class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">bai</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/04/engineer/git-commit-convention/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhen Huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/04/engineer/git-commit-convention/" itemprop="url">git提交记录规范</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-04T14:45:05+08:00">
                2019-12-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>git commit</code>是日常开发中用到最多的指令之一。一般情况下，我都是<code>git commit -m &#39;xxxx&#39;</code>。之前也有稍微了解<code>git commit</code>的提交规范，但是一般都只用下<code>feat</code>表示新增功能。这两天比较闲，正好系统的梳理了一些东西。以下是对 commit message 规范的一些理解。</p>
<h1 id="为什么需要规范-commit-message"><a href="#为什么需要规范-commit-message" class="headerlink" title="为什么需要规范 commit message"></a>为什么需要规范 commit message</h1><p>commit message 现在最常用的规范应该是<a href="https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#heading=h.greljkmo14y0" target="_blank" rel="noopener">Angular 规范</a>，文档很短，有效内容只有 4-5 页 word。</p>
<p>在文档的开头，goals 提到了这套规范的目的：</p>
<ol>
<li>自动生成 CHANGELOG.md</li>
<li>区分不重要的提交</li>
<li>提供更多的信息</li>
</ol>
<p>当然，这个文档很老了，更新的 AngularJS 规范可以看<a href="https://github.com/angular/angular/blob/master/CONTRIBUTING.md#-commit-message-guidelines" target="_blank" rel="noopener">github/AngularJS</a></p>
<h1 id="Angular-JS-commit-message-规范"><a href="#Angular-JS-commit-message-规范" class="headerlink" title="Angular JS commit message 规范"></a>Angular JS commit message 规范</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line">&lt;BLANK LINE&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;BLANK LINE&gt;</span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure>
<p>Angular JS 的 commit message 规范包含三部分：头部、正文、尾部。其中正文和尾部可以省略，如果有，相互之间必须有空行。</p>
<h2 id="头部"><a href="#头部" class="headerlink" title="头部"></a>头部</h2><p>其中头部包含三部分：</p>
<ol>
<li>type,操作类型。操作类型是固定的，只能从固定的列表中选择，详细见下面列表</li>
<li>scope,修改文件范围。这个是可选的，如果项目要写，就应该事先确定可以填哪些，不允许自由发挥。scope 之后应该跟冒号和空格，分隔 subject。如果没有 scope，就跟在 type 之后。</li>
<li>subject,本次修改的简单描述。注意长度控制。如果修改内容较多，应在正文中详细描述。以动词开头，结尾不需要句号</li>
</ol>
<p>type 类型</p>
<ul>
<li>build: 打包、配置修改</li>
<li>ci: 持续集成配置修改</li>
<li>docs: 修改文档</li>
<li>feat: 新增特性</li>
<li>fix: 修复 bug</li>
<li>perf: 性能优化</li>
<li>refactor: 重构</li>
<li>style: 不是 css 修改! 格式修改，如空格、逗号等。</li>
<li>test: 测试</li>
<li>revert: 回退</li>
</ul>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>对提交内容的详细描述<br>以动词开头</p>
<h2 id="尾部"><a href="#尾部" class="headerlink" title="尾部"></a>尾部</h2><p>如果有不兼容的更新，需要写明<br>如果是针对某个 issue 的 fix，需要给出 issue 链接</p>
<h1 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h1><h2 id="限制不符合规范的-message-提交"><a href="#限制不符合规范的-message-提交" class="headerlink" title="限制不符合规范的 message 提交"></a>限制不符合规范的 message 提交</h2><p><a href="https://www.npmjs.com/package/@commitlint/cli" target="_blank" rel="noopener">@commitlint/cli</a>结合<a href="https://www.npmjs.com/package/husky" target="_blank" rel="noopener">husky</a>可以阻止不符合规范的 comit message 提交</p>
<p>使用方法：</p>
<ol>
<li><p>安装<code>@commitlint/cli</code>、<code>@commitlint/config-conventional</code>和<code>husky</code></p>
<p> <code>npm i -D @commitlint/cli @commitlint/config-conventional husky</code></p>
</li>
<li><p>项目根目录新建<code>commitlint.config.js</code>文件</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// commitlint.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    extends: [<span class="string">"@commitlint/config-conventional"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>package.json 中配置 commit-msg 钩子</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// package.json</span><br><span class="line">&#123;</span><br><span class="line">    // 其它配置</span><br><span class="line">    "husky": &#123;</span><br><span class="line">        "hooks": &#123;</span><br><span class="line">            "commit-msg": "commitlint -E HUSKY_GIT_PARAMS"</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，在执行 git commit 时，如果提交的内容不符合<code>@commitlint/config-conventional</code>，就无法提交成功</p>
<h3 id="为什么使用-commitlint-config-conventional而不是-commitlint-config-angular。"><a href="#为什么使用-commitlint-config-conventional而不是-commitlint-config-angular。" class="headerlink" title="为什么使用@commitlint/config-conventional而不是@commitlint/config-angular。"></a>为什么使用<code>@commitlint/config-conventional</code>而不是<code>@commitlint/config-angular</code>。</h3><p>主要是因为 angular 规范对于 build 的定义有一些歧义，实际使用中 build 一般用于表示打包，而修改打包配置文件使用 chore</p>
<h2 id="commitizen"><a href="#commitizen" class="headerlink" title="commitizen"></a>commitizen</h2><p><a href="https://www.npmjs.com/package/commitizen" target="_blank" rel="noopener">commitizen</a> 是一个生成符合规范 commit message 的工具。</p>
<p>使用方法：</p>
<p>全局安装 commitizen<br><code>npm i -g commitizen</code></p>
<p>然后安装<a href="https://www.npmjs.com/package/cz-conventional-changelog" target="_blank" rel="noopener">cz-conventional-changelog</a></p>
<p>在<code>package.json</code>中配置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// package.json</span><br><span class="line">&#123;</span><br><span class="line">    // 其它配置</span><br><span class="line">    "config": &#123;</span><br><span class="line">        "commitizen": &#123;</span><br><span class="line">            "path": "cz-conventional-changelog"</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在使用<code>git commit</code>的地方使用<code>git cz</code>替代就可以了</p>
<h2 id="自动生成-CHANGELOG"><a href="#自动生成-CHANGELOG" class="headerlink" title="自动生成 CHANGELOG"></a>自动生成 CHANGELOG</h2><p><a href="https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-cli" target="_blank" rel="noopener">conventional-changelog-cli</a>可以根据 commit 记录自动生成 CHANGELOG</p>
<p>有两点要求</p>
<ol>
<li>commit message 符合 angular 规范</li>
<li>正确设置 git tag 和 package.json 的 version，否则无法识别哪些提交时当前版本的</li>
</ol>
<p>使用方式</p>
<ol>
<li>安装<code>conventional-changelog-cli</code></li>
</ol>
<p><code>npm install -D conventional-changelog-cli</code></p>
<ol start="2">
<li>在 package.json 中增加 scripts</li>
</ol>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// package.json</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">        <span class="attr">"changelog"</span>: <span class="string">"conventional-changelog -p angular -i CHANGELOG.md -s"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行<code>npm run changelog</code><br>这种方式不会覆盖 CHANGELOG.md 之前的内容，而是在最前面增加这个版本的修改。只会加入 feat 和 fix 的内容</p>
<p>涉及版本号修改以及 git tag，正确的工作流程应该是</p>
<ol>
<li>版本内容修改</li>
<li>修改版本号</li>
<li>生成 CHANGELOG</li>
<li>git commit</li>
<li>git tag</li>
<li>git push</li>
</ol>
<h2 id="关于-commit-粒度"><a href="#关于-commit-粒度" class="headerlink" title="关于 commit 粒度"></a>关于 commit 粒度</h2><p>前面规范中讲过，每次提交都需要指定一个 type，那么如果一次修改中包含多个 type 的内容怎么办。</p>
<p>不应该这样做。</p>
<p>每一次 commit 的提交的内容应该只包含一个功能，不要同时修改多个功能。</p>
<p>这样提交的内容比较清晰明了，对 codereview 也比较友好。</p>
<p>google 在其公开的<a href="https://github.com/google/eng-practices/blob/master/review/developer/small-cls.md" target="_blank" rel="noopener">Google Engineering Practices Documentation</a>对这个问题做了详细描述</p>
<p>也可以看<a href="https://github.com/xindoo/eng-practices-cn" target="_blank" rel="noopener">谷歌工程实践-中文翻译版</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/28/engineer/webpack-04/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhen Huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/28/engineer/webpack-04/" itemprop="url">webpack构建速度与体积优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-28T20:40:01+08:00">
                2019-11-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>提到优化，一般都是下面几个流程</p>
<ol>
<li>确定优化目标和指标，指标有时候很容易，有时候会很复杂。因为目标是定性的，而指标必须量化。</li>
<li>获取现有数据。主要是为了发现问题，确认优化方向</li>
<li>确认优化方案，执行。</li>
<li>比对优化前后数据，确认优化效果。给领导汇报。</li>
</ol>
<p>任何没有目标的优化，都是耍流氓。</p>
<p>具体到 webpack 优化，目标是提高 webpack 的构建速度，缩小构建后文件大小。</p>
<p>下文会详细讲解检测构建速度和构建体积以及优化方案。</p>
<h1 id="构建速度与体积检测"><a href="#构建速度与体积检测" class="headerlink" title="构建速度与体积检测"></a>构建速度与体积检测</h1><h2 id="stats"><a href="#stats" class="headerlink" title="stats"></a>stats</h2><p>最简单的衡量打包速度和打包文件体积的方法可以使用 webpack 内置的 stats，在不配置 stats 的情况下，webpack 打包完成后会显示打包的时间以及每个文件的大小。<br><img src="/images/webpack-04.1.jpg" alt="stats"></p>
<p>这种方式最简单，但是缺点也很明显。粒度太粗。只显示了整个项目的打包时间和每个文件的大小，而不能分析是哪个步骤打包慢或者一个大文件包含了哪些内容。</p>
<p>所以 stats 一般只用来对粗略性的评估 webpack 的打包结果。想要更细致的评估 webpack 的打包，就必须有更详细的数据。</p>
<h2 id="构建速度检测"><a href="#构建速度检测" class="headerlink" title="构建速度检测"></a>构建速度检测</h2><p><a href="https://www.npmjs.com/package/speed-measure-webpack-plugin" target="_blank" rel="noopener">speed-measure-webpack-plugin</a>检测 webpack 各个 loader、plugin 的耗时，并按时间排序。<br><img src="/images/webpack-04.2.jpg" alt="speed-measure-webpack-plugin效果图片"><br>图中时间较长会显示红色，一般表示需要优化，当然，还看具体情况。</p>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> SpeedMeasurePlugin = <span class="built_in">require</span>(<span class="string">"speed-measure-webpack-plugin"</span>)</span><br><span class="line"><span class="keyword">const</span> smp = <span class="keyword">new</span> SpeedMeasurePlugin()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">    <span class="comment">// webpack 配置</span></span><br><span class="line">    stats: <span class="string">"errors-only"</span> <span class="comment">// 建议优化时开启</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = smp.wrap(webpackConfig)</span><br></pre></td></tr></table></figure>
<p>由于 stats 默认会显示构建时间等，这种情况下建议将 stats 设置为<code>errors-only</code>，只显示错误</p>
<h2 id="构建体积检测"><a href="#构建体积检测" class="headerlink" title="构建体积检测"></a>构建体积检测</h2><p>构建体积检测可以使用插件<a href="https://www.npmjs.com/package/webpack-bundle-analyzer" target="_blank" rel="noopener">webpack-bundle-analyzer</a><br><img src="/images/webpack-04.3.jpg" alt="webpack-bundle-analyzer效果图片"></p>
<p>该插件会启动一个本地服务，展示打包后各个文件的大小，以及组成部分的大小。<br>比如从上图我们可以知道为什么 vendor.js 会这么大，然后具体优化。</p>
<h3 id="使用方式-1"><a href="#使用方式-1" class="headerlink" title="使用方式"></a>使用方式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; BundleAnalyzerPlugin &#125; = <span class="built_in">require</span>(<span class="string">"webpack-bundle-analyzer"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// 其它配置</span></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="comment">// 其它插件</span></span><br><span class="line">        <span class="keyword">new</span> BundleAnalyzerPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/28/engineer/webpack-03/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhen Huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/28/engineer/webpack-03/" itemprop="url">可维护的webpack配置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-28T20:39:57+08:00">
                2019-11-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/28/engineer/webpack-02/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhen Huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/28/engineer/webpack-02/" itemprop="url">webpack进阶用法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-28T20:39:54+08:00">
                2019-11-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/28/engineer/webpack-01/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhen Huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/28/engineer/webpack-01/" itemprop="url">webpack基础用法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-28T20:39:23+08:00">
                2019-11-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本系列文章是对极客时间课程–<a href="https://time.geekbang.org/course/intro/190" target="_blank" rel="noopener">玩转 webpack</a> 的总结。<br>章节上基本按照玩转 webpack 的章节</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/21/engineer/babel/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhen Huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/21/engineer/babel/" itemprop="url">babel</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-21T15:47:10+08:00">
                2019-11-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>对<a href="https://juejin.im/post/5c19c5e0e51d4502a232c1c6" target="_blank" rel="noopener">一口(很长的)气了解 babel</a>的总结</p>
<h1 id="babel-是什么"><a href="#babel-是什么" class="headerlink" title="babel 是什么"></a>babel 是什么</h1><p>babel 官网对于 babel 的定义是：Babel 是一个 JavaScript 编译器。</p>
<p>紧随其后，babel 官网给出了为什么需要 babel 的理由：今天就开始使用下一代的 JavaScript 语法编程吧！</p>
<p>这就是 babel 的主要作用，将浏览器还不支持的新语法转换为浏览器支持的语法。</p>
<h1 id="babel-原理"><a href="#babel-原理" class="headerlink" title="babel 原理"></a>babel 原理</h1><p>babel 是如何做到这一点呢。</p>
<p>babel 对代码的处理包含三步：</p>
<ol>
<li>解析(parse)</li>
<li>转换(transform)</li>
<li>生成(generate)</li>
</ol>
<p>解析阶段 babel 会将代码转换成抽象语法树(AST)。关于什么是 AST 就不介绍了，babel 也不是自己做的转换，而是使用 balylon 这个包，现在叫@babel/parse</p>
<p>转换阶段 babel 使用配置的插件对 AST 进行操作（关于如何配置插件，会在 babel 使用中讲到）。如果没有配置任何插件，则不做任何转换。</p>
<p>生成阶段，babel 将操作后的 AST 生成 js 代码。</p>
<p>关于转换阶段，这里其实有点疑惑。<br>babel 要生成 AST 后才去执行插件的转换，那么是不是意味这@babel/parse 必须先支持这种语法，否则在解析阶段就会报错。对 AST 的生成不了解，所以不确定会不会报错。</p>
<h1 id="babel-使用"><a href="#babel-使用" class="headerlink" title="babel 使用"></a>babel 使用</h1><h2 id="babel-使用方式"><a href="#babel-使用方式" class="headerlink" title="babel 使用方式"></a>babel 使用方式</h2><p>babel 的使用方式主要有两种</p>
<ol>
<li>使用命令行(cli)</li>
<li>构建工具插件(babel-loader、roll-plugin-babel 等)</li>
</ol>
<p>不同的使用方式的差别只是 babel 的入口不同，使用命令行需要安装<code>@babel/cli</code>，构建工具插件需要安装<code>babel-loader</code>。<br>而在配置、原理部分，不同的使用方式没有区别。</p>
<h3 id="babel-cli"><a href="#babel-cli" class="headerlink" title="@babel/cli"></a>@babel/cli</h3><p><code>@babel/cli</code>的使用方式很简单，安装<a href="https://www.npmjs.com/package/@babel/cli" target="_blank" rel="noopener">@babel/cli</a>，然后在<code>package.json</code>中增加<code>scripts:babel</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // 其它配置</span><br><span class="line">    "scripts": &#123;</span><br><span class="line">        // 其它scripts</span><br><span class="line">        "babel": "babel src --out-dir dist"</span><br><span class="line">        // 其中src是源码目录，dist是babel处理后的代码生成目录</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后执行<code>npm run babel</code>，babel 就会将 src 中的代码执行转换，然后在 dist 目录生成。当然，如果没有做任何配置，生成的代码和源码是一样的。</p>
<h3 id="工具插件-babel-loader-为例"><a href="#工具插件-babel-loader-为例" class="headerlink" title="工具插件(babel-loader 为例)"></a>工具插件(babel-loader 为例)</h3><p>babel 更常见的情况是和打包工具一起使用。以 webpack 为例。webpack 中使用 babel 需要安装 <a href="https://www.npmjs.com/package/babel-loader" target="_blank" rel="noopener">babel-loader</a>，然后做如下配置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js 或其他webpack配置文件</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//  其他配置</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            <span class="comment">// 其他loader</span></span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">                use: <span class="string">"babel-loader"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>babel-loader 也会使用配置文件(.babelrc)中的配置</p>
<h2 id="babel-配置"><a href="#babel-配置" class="headerlink" title="babel 配置"></a>babel 配置</h2><p>babel 的转换效果完全依赖于配置，没有任何配置的 babel 不会进行任何代码转换。<br>babel 的配置一般使用<code>.babelrc</code>文件，也支持<code>package.json</code>等其他配置方式，具体见<a href="https://babeljs.io/docs/en/configuration#packagejson" target="_blank" rel="noopener">babel 官网</a></p>
<p>在 babel 原理中讲到，babel 对代码的转换完全依赖于插件。所以 babel 的配置就是对使用插件的配置。<br>实际使用中，由于要使用到的插件很多，所以还可以使用<code>preset</code>，preset 是插件的集合，一个 preset 会包含多个插件。配置中声明了一个 preset，就等同于声明了一大堆 plugin。</p>
<p>配置示例</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// .babelrc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"presets"</span>: [</span><br><span class="line">        [</span><br><span class="line">            <span class="string">"@babel/preset-env"</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"useBuiltIns"</span>: <span class="string">"usage"</span>,</span><br><span class="line">                <span class="attr">"corejs"</span>: &#123;</span><br><span class="line">                    <span class="attr">"version"</span>: <span class="number">3</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"plugins"</span>: [<span class="string">"@babel/plugin-transform-runtime"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>presets 和 plugins 的配置都是数组，如果 plugin/preset 不需要传递参数，直接使用 preset/plugin 名称字符串即可。如果还需要传递参数，则可以传入一个数组，数组第一位是 preset/plugin 名称，第二位是一个对象，表示传入的参数。</p>
<h3 id="babel-插件详解"><a href="#babel-插件详解" class="headerlink" title="babel 插件详解"></a>babel 插件详解</h3><p>配置说了一堆，但是实际项目中到底应该怎么配置呢<br>要了解实际项目中要怎么配置，还需要先了解 babel 的常见插件有什么用</p>
<h4 id="babel-preset-env"><a href="#babel-preset-env" class="headerlink" title="@babel/preset-env"></a>@babel/preset-env</h4><p><strong>env 是 babel 最常用、最重要的插件。</strong><br>env 插件的作用是根据打包的目的环境做不同的转换，目的环境可以在<code>env</code>配置的第二个参数中传入。比如如果目标环境包含 ie8，那么箭头函数就必须做转换，而如果目标环境只包含最新版的 chrome，那么箭头函数就不需要转换。<br>示例如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"presets"</span>: [</span><br><span class="line">        [</span><br><span class="line">            <span class="string">"env"</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"targets"</span>: &#123;</span><br><span class="line">                    <span class="attr">"browsers"</span>: [<span class="string">"last 2 versions"</span>, <span class="string">"safari &gt;= 7"</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更推荐的做法是使用<code>.browserslistrc</code>配置文件，因为这样可以和其它插件共用配置。具体语法见<a href="https://github.com/browserslist/browserslist" target="_blank" rel="noopener">browserslist</a></p>
<p><strong>env 只会转换语法</strong>，如箭头函数、class 等，而不会对实例、静态方法、API 做转换，如 Array.from、[].includes</p>
<h4 id="babel-polyfill"><a href="#babel-polyfill" class="headerlink" title="babel-polyfill"></a>babel-polyfill</h4><p>babel-polyfill 是对 es6 后的新的静态、实例方法、API 的模拟实现，如 Iterator、Set、Map、Array.from 等。内部集成了 core-js 和 regenerator。所以这些实现也不是 babel-polyfill 自己做的。</p>
<p>babel-polyfill 的使用一般是在项目入口 js 文件的第一行引入</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="comment">// 在第一行引入，防止引入的第三方包报错</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"babel-polyfill"</span></span><br></pre></td></tr></table></figure>
<p>所以 env + babel-polyfill 可以实现对所有不支持语法、API 的转换。</p>
<h4 id="babel-plugin-transform-runtime、-babel-runtime"><a href="#babel-plugin-transform-runtime、-babel-runtime" class="headerlink" title="@babel/plugin-transform-runtime、@babel/runtime"></a>@babel/plugin-transform-runtime、@babel/runtime</h4><p><code>@babel/plugin-transform-runtime</code>是为了弥补<code>env</code>转换的缺点，而<code>@babel/runtime</code>是<code>transform-runtime</code>转换时需要用到的插件</p>
<p>以 class 语法为例，env 转换前后的代码示例如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">"hz"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------- 转换后代码 ---------------</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_classCallCheck</span>(<span class="params">instance, Constructor</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 具体实现，不重要</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    _classCallCheck(<span class="keyword">this</span>, Person)</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"hz"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种实现的缺点在于每一个模块中都会引入一个<code>_classCallCheck</code>实现，如果模块很多，就可能使得打包后体积显著增大</p>
<p>而使用<code>@babel/plugin-transform-runtime</code>会转换后的效果如下所示</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">"hz"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------- 转换后代码 ---------------</span></span><br><span class="line"></span><br><span class="line">;(<span class="string">"use strict"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _interopRequireDefault = <span class="built_in">require</span>(<span class="string">"@babel/runtime/helpers/interopRequireDefault"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _classCallCheck2 = _interopRequireDefault(<span class="built_in">require</span>(<span class="string">"@babel/runtime/helpers/classCallCheck"</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ;(<span class="number">0</span>, _classCallCheck2[<span class="string">"default"</span>])(<span class="keyword">this</span>, Person)</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"hz"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，class 的模拟实现<code>_classCallCheck2</code>引用自外部插件<code>@babel/runtime</code>，这样就解决了每个模块都需要实现 class 模拟的问题。这也是为什么<code>transform-runtime</code>需要与<code>@babel/runtime</code>一起使用的原因，真正的模拟实现都来自于<code>@babel/runtime</code>插件。</p>
<p><code>@babel/plugin-transform-runtime</code>只是解决了<code>env</code>转换的缺点，同样也只能转换语法，而不能转换静态、实例方法、API</p>
<h4 id="stage-0、stage-1、es2015-xx-等"><a href="#stage-0、stage-1、es2015-xx-等" class="headerlink" title="stage-0、stage-1、es2015-xx 等"></a>stage-0、stage-1、es2015-xx 等</h4><p>在实际的项目中,除了上述的 plugin/preset 外，我们还是会看到很多其他的插件，他们大多是对某个特定的功能进行转换，在新的项目中，不建议在使用这种方式，env 就足够了。<br>本文也不打算继续介绍这些。</p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>前面讲到，env + babel-polyfill 就可以实现所有的转换，而<code>@babel/plugin-transform-runtime</code>插件可以解决 env 插件的缺点。</p>
<p>然而<code>babel-polyfill</code>也有缺点。<code>babel-polyfill</code>会引入所有的新 API 模拟实现，而不管需不需要。而整个<code>babel-polyfill</code>非常大，在比较小的项目中，尤其移动端项目，会显著增大打包后体积。</p>
<p>为此，babel7 中 env 插件增加了参数<code>useBuiltIns:&#39;usage&#39;</code>,可以根据使用情况动态引入需要的<code>core-js</code>模拟实现。因此，使用此参数需要安装<code>core-js</code>包</p>
<p>babel 的常用配置如下</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// .babelrc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"presets"</span>: [</span><br><span class="line">        [</span><br><span class="line">            <span class="string">"@babel/preset-env"</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"useBuiltIns"</span>: <span class="string">"usage"</span>,</span><br><span class="line">                <span class="attr">"corejs"</span>: &#123;</span><br><span class="line">                    <span class="attr">"version"</span>: <span class="number">3</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"plugins"</span>: [<span class="string">"@babel/plugin-transform-runtime"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// .browserslistrc</span><br><span class="line">// 根据项目实际需求设置</span><br><span class="line">defaults</span><br></pre></td></tr></table></figure>
<p>使用<code>env</code>做语法转换，增加<code>useBuiltIns:&quot;usage&quot;</code>配置做静态、示例方法转换(通过引入 core-js 的模拟实现)，其中<code>core-js</code>用于指定<code>core-js</code>版本<br>使用<code>@babel/plugin-transform-runtime</code>解决语法转换每个模块重复的问题（上文已讲到）<br>最后，还需要增加<code>.browserslistrc</code>文件指定<code>env</code>插件的目标环境</p>
<h1 id="babel-插件书写"><a href="#babel-插件书写" class="headerlink" title="babel 插件书写"></a>babel 插件书写</h1><p>不会，可参考<a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-check-if-a-node-is-a-certain-type" target="_blank" rel="noopener">babel 插件手册</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/09/basis/execution/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhen Huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/09/basis/execution/" itemprop="url">js 执行过程概述</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-09T20:01:01+08:00">
                2019-09-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>讲述浏览器中 js 的执行过程</p>
<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>浏览器是单线程的，代码的执行按照从上到下的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>,</span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(a + b)</span><br></pre></td></tr></table></figure>
<p>对于这样简单的顺序代码，这样的执行逻辑没有什么问题。</p>
<p>但是实际情况会复杂一些，比如，代码执行过程中有一个点击事件触发，那应该怎样处理呢。由于主线程可能正在执行其他任务，所以无法及时响应点击事件。所以简单的顺序执行无法满足。</p>
<p>因此浏览器引入了任务队列和循环机制。任务队列用于保存所有需要执行的任务，比如点击事件、页面渲染事件等。<br>主线程则不断的从任务队列从取出任务，然后执行。可以用伪代码表示如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TaskQueue = []</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    task = TaskQueue.shift()</span><br><span class="line">    ProcessTask(task)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一个不断循环的过程被称作事件循环。</p>
<p>js 中通过 setTimeout 可以创建定时任务，在一定时间后执行。那么浏览器如何确保这个任务在一定时间后执行呢。</p>
<p>按照现有的循环机制，只能在一定时间后将定时任务加入到任务队列中，但是此时任务队列中可能已经存在多个任务，定时任务的顺序可能被极大的延后。</p>
<p>因此，浏览器又增加了定时任务队列。定时器触发的任务会增加到定时任务中，浏览器主线程执行完一个任务队列中的任务后，会查询定时任务队列中是否有任务。可以用伪代码表示如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TaskQueue = []</span><br><span class="line">DelayTaskQueue = []</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    task = TaskQueue.shift()</span><br><span class="line">    ProcessTask(task)</span><br><span class="line">    task = DelayTaskQueue.get()</span><br><span class="line">    ProcessDelayTaskQueue(task)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的任务队列可以尽量使定时任务的时间接近设定的时间，但仍然无法确保定时任务一定会在设定的时间触发。因为还是有可能因为某个任务的执行而延迟定时任务的执行。</p>
<p>前面设计的任务队列中，还存在一个问题，即如何区分任务的优先级。前面设计的任务队列，所有任务的优先级都是一样的，我们没法让某个任务优先执行。<br>为此，浏览器引入了微任务的概念。</p>
<p>浏览器在执行完一个宏任务后，开始下一个宏任务之前，会循环执行当前的微任务队列，直到当前微任务队列为空，才会继续执行下一个宏任务。</p>
<p>可以用伪代码表示如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TaskQueue = []</span><br><span class="line">DelayTaskQueue = []</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    task = TaskQueue.shift()</span><br><span class="line">    ProcessTask(task)</span><br><span class="line">    ProcessAllMicroTasks()</span><br><span class="line">    task = DelayTaskQueue.get()</span><br><span class="line">    ProcessDelayTaskQueue(task)</span><br><span class="line">    ProcessAllMicroTasks()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>在每一个宏任务/微任务中，执行的都是一段段的代码。</p>
<p>每一段代码的执行都需要一个环境，包含代码执行所需的所有条件。在 js 中，这个环境叫做执行上下文(execution context)。</p>
<h3 id="执行上下文的类别"><a href="#执行上下文的类别" class="headerlink" title="执行上下文的类别"></a>执行上下文的类别</h3><p>那什么样的代码能称之为一段代码呢。这样的说法可能不太准确，更准确的说法应该是。</p>
<p>什么样的代码会生成新的执行上下文呢?</p>
<p>在 js 中，只有三种执行上下文。所以也只有在这三种情况下会生成新的执行上下文。</p>
<ol>
<li>全局执行上下文</li>
<li>函数执行上下文</li>
<li>eval 执行上下文</li>
</ol>
<p>全局执行上下文只有一个，在 js 引擎生成时就会生成。<br>函数执行上下文在执行新的函数时生成。<br>eval 执行上下文在执行 eval 时生成</p>
<p>三种执行上下文概念上大体类似，细节处稍有不同，具体细节在讲到执行上下文组成部分时讲解。</p>
<h4 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h4><p>在代码的执行过程中，并不是只有一个执行上下文生成。而是伴随执行的过程不断生成新的执行上下文、销毁旧的执行上下文。</p>
<p>多个执行上下文需要一个结构来保存，这就是执行栈。</p>
<p>执行栈用于保存所有的执行上下文。</p>
<p>执行栈是一个典型的栈结构。即后进入栈的执行上下文先出栈。<br>生成新的执行上下文生成时会入栈，代码执行完成后当前执行上下文出栈。</p>
<h4 id="执行上下文的内容"><a href="#执行上下文的内容" class="headerlink" title="执行上下文的内容"></a>执行上下文的内容</h4><p>前面讲到，执行上下文包含了代码执行所需的所有条件，那么执行上下文到底包含了那些内容呢。<br>执行上下文的内容在 js 的各个版本中经历了比较大的变化。下面将讲述各个版本的执行上下文</p>
<h5 id="es3-中的执行上下文"><a href="#es3-中的执行上下文" class="headerlink" title="es3 中的执行上下文"></a>es3 中的执行上下文</h5><p>在 es3 时期，执行上下文包含三个部分: this、变量对象(VO)、作用域链(Scope)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从理解角度我们可以这样认为</span></span><br><span class="line">Execution Context = &#123;</span><br><span class="line">    <span class="keyword">this</span>,</span><br><span class="line">    VO,</span><br><span class="line">    Scope</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="this"><a href="#this" class="headerlink" title="this"></a>this</h6><p>this 是执行上下文的一部分，this 的指向也是一个比较复杂的话题，这里不展开。因为 this 的指向和执行过程的关系不大。</p>
<h6 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h6><p>代码在执行时会定义一些变量，这些变量都定义在变量对象中。<br>变量对象包含了在当前执行上下文中声明的所有变量。</p>
<p>以函数执行上下文为例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">talk</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">say()</span><br></pre></td></tr></table></figure>
<p>上面的函数 say 形成的执行上下文中变量对象可以用如下的代码表示</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vo = &#123;</span><br><span class="line">    x,</span><br><span class="line">    y,</span><br><span class="line">    <span class="built_in">arguments</span>,</span><br><span class="line">    talk</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的例子看到，函数 say 形成的执行上下文中包含了 say 中声明的所有变量和函数，也包含了没有声明的 arguments 变量，这也是可以在函数中直接访问 arguments 的原因。</p>
<p>在全局执行上下文中，变量对象就是全局上下文本身，也就是 window</p>
<p>在规范中，变量对象被定义为一个普通对象，其实这是个 bug，变量对象并不是普通对象，没有原型，所以变量查找不会沿着原型链上溯</p>
<h6 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h6><p>前面讲到，变量对象中存储了所有当前执行上下文中声明的变量（函数声明也是声明变量的一种方式）。<br>那么函数中如何访问变量呢，对于函数中定义的变量，可以通过变量对象访问。<br>但是函数中会访问函数中定义的变量，还会访问函数外定义的变量。</p>
<p>作用域(Scope)，也称为作用域链，用于控制执行上下文中所有变量的访问。</p>
<p>作用域是一个包含当前上下文和外部所有上下文变量对象的队列。<br>可以用如下代码表示</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scope = VO + [[Scope]]</span><br></pre></td></tr></table></figure>
<p><code>[[Scope]]</code>是一个函数的内部属性，在函数创建时生成，包含了所有函数外部执行上下文的变量对象。</p>
<p>[[Scope]] = [VO1,VO2,VO3,…]</p>
<p>[[Scope]]在函数创建时生成，在函数的生命周期中一直存在，这也是为什么闭包可以访问函数外部变量的原因。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> closure = <span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="number">4</span></span><br><span class="line">        <span class="built_in">console</span>.log(a + b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">closure()</span><br></pre></td></tr></table></figure>
<p>在执行函数 closure 时，函数 outer 的执行已结束，执行上下文也已出栈，但是 closure 仍然可以访问变量 a，因为函数 closure 的[[Scope]]属性会直接引用 outer 的变量对象。</p>
<h5 id="执行上下文的两个过程"><a href="#执行上下文的两个过程" class="headerlink" title="执行上下文的两个过程"></a>执行上下文的两个过程</h5><p>至此，已经讲完了 es3 中执行上下文的组成部分。<br>执行上下文的三部分，this 不讲，变量对象用于存储执行上下文中声明的变量，作用域用于执行上下文中访问变量时的查找。</p>
<p>但是关于变量的声明和查找，我们还需要更详细的讲解一下。</p>
<p>以函数执行上下文为例。<br>函数的执行过程包含两部分</p>
<ol>
<li>进入函数时</li>
<li>函数执行时</li>
</ol>
<p>对于语句<code>var a = 1</code>，对于 js 引擎而言，其实包含两部分</p>
<ol>
<li>var a，这是变量声明</li>
<li>a = 1 这是变量赋值</li>
</ol>
<p>其中变量声明在<strong>进入函数时</strong>进行，变量赋值在<strong>函数执行时</strong>进行。</p>
<p>进入函数时会执行以下过程</p>
<ol>
<li>声明 arguments 和函数声明的参数并赋值（对于非函数执行上下文没有这一步）</li>
<li>函数声明会声明函数同名变量并赋值，如果存在同名的变量，会覆盖</li>
<li>变量声明会被声明，并被赋值为 undefined，如果已存在同名变量，会跳过</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b, c) <span class="comment">// 1 ƒ b() &#123;&#125; 3 undefined</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">999</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b, c) <span class="comment">// 999 ƒ b() &#123;&#125; 3 888</span></span><br><span class="line">&#125;</span><br><span class="line">say(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<ol>
<li>上例中，变量 b 是函数的参数，同时也存在函数内部声明的函数 b，所以变量 b 被覆盖为函数 b。</li>
<li>而 a 因为函数内部声明的是变量，所以声明操作被跳过，所以值还是 1</li>
<li>c 没有同名变量，所以是 3 不变</li>
<li>d 是函数内部声明的变量，所以被声明，但是值是 undefined</li>
</ol>
<p>函数执行时</p>
<p>这个没什么好讲的，逐句代码执行</p>
<h5 id="es5-中的执行上下文"><a href="#es5-中的执行上下文" class="headerlink" title="es5 中的执行上下文"></a>es5 中的执行上下文</h5><p>es5 中的执行上下文同样包含三个部分</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">es5EC = &#123;</span><br><span class="line">    <span class="keyword">this</span>,</span><br><span class="line">    lexicalEnvironment, <span class="comment">// 词法作用域</span></span><br><span class="line">    variableEnvironment <span class="comment">// 变量作用域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>this 略过不讲。</p>
<p>其中词法作用域和变量作用域大部分时候是同一个对象，只在某些特殊的情况下，比如 with，两者会有不同，因为 with 已经不推荐使用，所以此处略过，大部分时候也不需要考虑两者之间的区别。</p>
<p>词法作用域(LexicalEnvironment)包含两部分</p>
<ol>
<li>环境记录，包含当前所有上下文声明所有变量的对象</li>
<li>outer，包含当前上下文的父级上下文的引用。对于全局上下文，这个值是 null</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">say(<span class="number">10</span>)</span><br><span class="line"><span class="comment">// 词法作用域和变量对象类似，同样包含两个阶段，此处是进入函数时</span></span><br><span class="line">say.LexicalEnvironment = &#123;</span><br><span class="line">    environmentRecord: &#123;</span><br><span class="line">        <span class="built_in">arguments</span>: &#123; xxx &#125;,</span><br><span class="line">        a: <span class="number">10</span>,</span><br><span class="line">        b: <span class="literal">undefined</span></span><br><span class="line">    &#125;,</span><br><span class="line">    outer: globalEnvironment</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与作用域类似，如果在当前环境记录中找不到变脸，则会继续查找当前词法作用域的父级词法作用域。<br>与作用域不同的是，词法作用域只包含父级词法作用域的引用</p>
<p>可以发现，词法作用域和变量对象/作用域链的概念非常类似，更多的是名词和实现的变化。而词法作用域概念的引入，主要是为了实现上的效率问题。</p>
<h5 id="es6-中的执行上下文"><a href="#es6-中的执行上下文" class="headerlink" title="es6 中的执行上下文"></a>es6 中的执行上下文</h5><p>es6 中的执行上下文没有找到比较好的文章，先放着吧。<br>唯一确定的两点</p>
<ol>
<li>this 放到了 lexicalEnvironment 中，而不是在执行上下文中</li>
<li>lexicalEnvironment 用于声明函数和 let/const，而 variableEnvironment 用于 var 的声明</li>
</ol>
<h3 id="语句的执行"><a href="#语句的执行" class="headerlink" title="语句的执行"></a>语句的执行</h3><p>代码执行，到最后都变为，在一定的环境（执行上下文）中执行代码。</p>
<p>所以代码执行的最后一部分是语句执行。</p>
<p>语句可以分为以下四类</p>
<ol>
<li>普通语句，包含声明语句、表达式语句等</li>
<li>语句块，即用大括号包裹的语句。</li>
<li>控制语句，包含 while/for/switch/break/continue 等</li>
<li>标签语句</li>
</ol>
<p>在语句的执行阶段，值得注意的只有控制语句。（声明语句虽然也有特殊之处，但是并不是在语句执行阶段）。</p>
<p>如果没有控制语句，所有语句都是顺序执行。控制语句，顾名思义，就是控制语句的执行顺序。</p>
<p>控制语句的控制效果可以见下图（截图来自极客时间-重学前端课程）<br><img src="/images/语句执行.png" alt="控制语句"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/04/basis/asynciterator/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhen Huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/04/basis/asynciterator/" itemprop="url">异步迭代</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-04T19:04:27+08:00">
                2019-09-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h3><p>在<a href="https://baiyunshenghaishang.github.io/2019/03/25/basis/iterator/" target="_blank" rel="noopener">迭代器</a>中讲到了，<code>for...of</code>可以用来遍历可迭代对象，<br>相比于传统的 for 循环，<code>for...of</code>循环更加简洁</p>
<p><code>for...of</code>循环包含一个默认的约定，即可迭代对象的 next 方法必须是同步的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> generator())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item) <span class="comment">// 1 2 Promise对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，对于返回 Promise 对象可迭代对象，<code>for...of</code>循环并不能正确获取 Promise resolve 的值</p>
<h3 id="异步生成器"><a href="#异步生成器" class="headerlink" title="异步生成器"></a>异步生成器</h3><p>为了处理异步的迭代，js 增加了异步生成器和<code>for await ... of</code></p>
<p>下面是一个简单的异步生成器例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>* <span class="title">asyncGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(resolve, <span class="number">3000</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> gen = asyncGenerator()</span><br><span class="line">gen.next() <span class="comment">// Promise对象</span></span><br></pre></td></tr></table></figure>
<p>异步生成器是一个生成器函数，返回一个可迭代对象<br>但是不同于普通生成器返回的可迭代对象，异步生成器返回的可迭代对象每次调用 next 方法都会返回一个 Promise</p>
<h3 id="for-await-…of"><a href="#for-await-…of" class="headerlink" title="for await …of"></a>for await …of</h3><p>有了异步生成器，自然也需要异步迭代器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>* <span class="title">asyncGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(resolve, <span class="number">3000</span>))</span><br><span class="line">&#125;</span><br><span class="line">;(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> item <span class="keyword">of</span> asyncGenerator()) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(item) <span class="comment">// 1 2 undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>上面的例子中，<code>for await ... of</code>会先执行 next 方法，然后等待 next 方法返回的 Promise resolve,然后执行下一个 next 方法，然后等待下一个 Promise resolve，直到 next 方法返回 done：true</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/27/basis/async/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhen Huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/27/basis/async/" itemprop="url">异步函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-27T07:13:46+08:00">
                2019-08-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="为什么需要异步函数"><a href="#为什么需要异步函数" class="headerlink" title="为什么需要异步函数"></a>为什么需要异步函数</h3><p>异步函数时 js 新增的一种语法，用于异步的处理</p>
<p>js 中异步的处理经历了三个阶段</p>
<ol>
<li>回调函数</li>
<li>Promise</li>
<li>异步函数</li>
</ol>
<p>Promise 解决了很多回调函数的缺陷，比如回调地狱等，在回调函数的基础上前进了一大步</p>
<p>但是 Promise 并不完美，大量的 then 语法虽然结构上比回调函数清晰很多，但是同样令人眼花缭乱</p>
<p>所以我们需要一种更简洁的语法来表示异步编程，异步函数就是一种方案</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>异步函数也是一种函数，其声明方式和其它函数相同，唯一的区别是在 function 关键字之前需要加上 async 关键字，在异步函数内部可以使用 await 关键字。如果没有 function 关键字，需要在函数名之前加上 async 关键字</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> say = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="keyword">async</span> say() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>await 之后可以跟 Promsie 或者普通变量，如果是 Promise，异步函数会暂停执行，等待 Promise resolve 之后继续执行。await 的返回值就是 Promise 的决议值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pause = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">secs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(resolve, secs)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`paused <span class="subst">$&#123;secs&#125;</span> milsecs`</span>)</span><br><span class="line">&#125;</span><br><span class="line">pause(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure>
<p>上面的代码会在 3s 之后打印结果，这就是异步函数的最基本用法</p>
<p>异步函数会返回 Promise，如果异步函数执行报错，返回的 Promise 会执行 reject</p>
<h3 id="异步函数的错误处理"><a href="#异步函数的错误处理" class="headerlink" title="异步函数的错误处理"></a>异步函数的错误处理</h3><p>异步函数内部可以包含多个 await，任何 await 之后的 Promise reject 都会导致后续的 await 不会不行，异步函数返回的 Promise 会执行 reject</p>
<p>所以如果想某一个 await 之后的 Promise reject 之后继续执行，需要使用 catch 或者 try…catch</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> someThrowErrorPromise()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;&#125;</span><br><span class="line">    <span class="keyword">await</span> executePromiseAfterError()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> someThrowErrorPromise().catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">    <span class="keyword">await</span> executePromiseAfterError()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异步函数的模拟实现"><a href="#异步函数的模拟实现" class="headerlink" title="异步函数的模拟实现"></a>异步函数的模拟实现</h3><p>在生成器一章中讲到过，异步函数其实就是对生成器异步执行的一种标准化，所以完全可以用生成器来模拟异步函数。</p>
<p>当然，相比于生成器的模拟，异步函数的不需要执行器，而且语义更明确，所以还是推荐使用异步函数</p>
<p>在<a href="https://baiyunshenghaishang.github.io/2019/03/28/basis/generator/" target="_blank" rel="noopener">生成器</a>中已经详细讲解了如何模拟异步函数，这里只给出执行器的代码，其它的参考生成器一篇即可</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">tasks</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (result.done) <span class="keyword">return</span> resolve(result.value)</span><br><span class="line">            <span class="built_in">Promise</span>.resolve(result.value).then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">                step(gen.next(val))</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> gen = tasks(),</span><br><span class="line">            result = gen.next()</span><br><span class="line">        step(result)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>异步函数的出现是为了提供比 Promise 更简洁、语义更明确的异步代码。但是异步函数并不是完全取代 Promise，而是在 Promise 的基础上实现。从前面的代码中也可以看出，异步函数和 Promise 息息相关</p>
<p>所以并不是有了异步函数就不需要 Promise，我们仍然需要 Promise，只是在合适的地方，可以使用异步函数替代 Promise</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/15/engineer/code-quanlity/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhen Huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/15/engineer/code-quanlity/" itemprop="url">代码质量控制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-15T19:56:15+08:00">
                2019-08-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h3><p>关于代码质量问题的想法有段时间了，最开始考虑的是如何写出高质量的代码，拖来拖去最后不了了之。</p>
<p>前端时间看 eslint，考虑到可以使用 eslint 来保证提交代码的基本质量，于是就有了这篇文章。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>代码基本质量的控制，在我看来应该包含两部分</p>
<ol>
<li>代码格式，这部分主要是为了风格统一，以及防止意外的 git 冲突</li>
<li>代码基本质量，如声明的变量未使用这种低级错误</li>
</ol>
<p>第一点考虑使用 prettier 控制，第二点因为现在只有 js 的代码质量检测工具，使用 eslint</p>
<p>考虑到老项目的存在，选择 husky,lint-staged 在提交时检测修改的文件，否则在老项目添加 eslint 报错太多</p>
<p><strong>所以整体思路是在<code>git commit</code>前格式化所有文件，然后对 <code>.js,.vue,.jsx</code>文件执行 eslint 检测,如果 eslint 校验不通过，停止提交</strong></p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>配置包含三部分</p>
<ol>
<li>prettier 配置</li>
<li>eslint 配置</li>
<li>husky 和 lint-staged 配置</li>
</ol>
<h5 id="prettier-配置"><a href="#prettier-配置" class="headerlink" title="prettier 配置"></a>prettier 配置</h5><p>可参考 <a href="https://baiyunshenghaishang.github.io/2019/07/25/engineer/prettier/" target="_blank" rel="noopener">prettier 配置</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .prettierrc.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...require(<span class="string">"@baixiaogou/prettier-config"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑到打包后的文件都会在新增文件里面，所以需要增加<code>.prettierignore</code>，可以参考如下配置<br>node_modules 一般会在<code>.gitignore</code>中，所以不需要添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// .prettierignore</span><br><span class="line"></span><br><span class="line">dist</span><br><span class="line">**/*.min.*</span><br></pre></td></tr></table></figure>
<h5 id="eslint-配置"><a href="#eslint-配置" class="headerlink" title="eslint 配置"></a>eslint 配置</h5><p>可参考<a href="https://baiyunshenghaishang.github.io/2019/07/04/engineer/eslint/" target="_blank" rel="noopener">eslint 配置</a></p>
<p>注意，老项目不建议开启 eslint-loader，因为 eslint-loader 会检测全部代码，如果开启 eslint-loader，虽然提交时能通过校验，但是项目启动时会有很多报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .eslintrc.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    root: <span class="literal">true</span>,</span><br><span class="line">    parserOptions: &#123;</span><br><span class="line">        parser: <span class="string">"babel-eslint"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    parserOptions: &#123;</span><br><span class="line">        ecmaVersion: <span class="number">6</span>,</span><br><span class="line">        sourceType: <span class="string">"module"</span>,</span><br><span class="line">        ecmaFeatures: &#123;</span><br><span class="line">            jsx: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    env: &#123;</span><br><span class="line">        browser: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [<span class="string">"prettier"</span>, <span class="string">"html"</span>, <span class="string">"vue"</span>],</span><br><span class="line">    extends: [<span class="string">"eslint:recommended"</span>, <span class="string">"plugin:vue/recommended"</span>, <span class="string">"prettier"</span>],</span><br><span class="line">    rules: &#123;</span><br><span class="line">        <span class="string">"prettier/prettier"</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="husky-lint-staged-配置"><a href="#husky-lint-staged-配置" class="headerlink" title="husky/lint-staged 配置"></a>husky/lint-staged 配置</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// package.json</span><br><span class="line"> "husky": &#123;</span><br><span class="line">    "hooks": &#123;</span><br><span class="line">      "pre-commit": "lint-staged"</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  "lint-staged": &#123;</span><br><span class="line">    "src/*": [</span><br><span class="line">      "prettier --write",</span><br><span class="line">      <span class="string">"git add"</span></span><br><span class="line">    ],</span><br><span class="line">    "src/**/*.&#123;js,vue&#125;": [</span><br><span class="line">      "eslint",</span><br><span class="line">      <span class="string">"git add"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Zhen Huang">
            
              <p class="site-author-name" itemprop="name">Zhen Huang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">35</span>
                  <span class="site-state-item-name">博客</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">45</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhen Huang</span>
  <div class="powered-by">
    <i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
      本站访客数:<span id="busuanzi_value_site_uv"></span>
    </span>
  </div>
  
</div>



        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
