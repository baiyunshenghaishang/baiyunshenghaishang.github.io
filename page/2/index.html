<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="bai">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="bai">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="bai">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title>bai</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
    <a href="https://github.com/baiyunshenghaishang"><img style="position:absolute;top:0;right:0" width="149" height="149" src="https://github.blog/wp-content/uploads/2008/12/forkme_right_gray_6d6d6d.png?resize=149%2C149" class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">bai</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/14/basis/promise/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhen Huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/14/basis/promise/" itemprop="url">Promise</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-14T18:51:27+08:00">
                2019-04-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是-Promise"><a href="#什么是-Promise" class="headerlink" title="什么是 Promise"></a>什么是 Promise</h3><p>Promise 是 es6 中一种新的数据类型/结构，目的在于解决回调方式的一些问题，如回调地狱、控制权反转。</p>
<p>Promise 包含三种状态<code>pending</code>、<code>fulfilled</code>、<code>rejected</code>。Promise 一旦变成<code>fulfilled</code>或者<code>rejected</code>，状态就不能在改变。这也是 Promise 命名的来源，即状态只会改变一次。<br><code>fulfilled</code> 状态表示成功状态，<code>rejected</code> 表示失败状态。</p>
<p>Promise 包含一个值，在创建 Promise 时生成。具体见 <strong>创建 Promise</strong></p>
<h3 id="创建-Promise"><a href="#创建-Promise" class="headerlink" title="创建 Promise"></a>创建 Promise</h3><p>创建 Promise 有两种方式<br>一种是通过构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">123</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Promise 构造函数接受一个函数，函数接受两个参数，resolve 会决议传入的值，具体行为类似于 Promise.resolve，区别在于 resolve 方法永远返回一个新的 Promsie<br>reject 将 Promsie 变为<code>rejected</code>状态。<br>resolve 和 reject 的参数就是 Promise 的值</p>
<p>另外一种是通过 Promise 的静态方法<code>Promise.resolve</code>和<code>Promise.reject</code><br><code>Promise.reject</code> 会创建一个 <code>rejected</code> 状态的 Promise</p>
<p>对于 <code>Promise.resolve</code>，有一点不同。<br>resolve 在英文中的意思是决议，规范最后选择 resolve 而不是 fulfill，是因为<code>Promise.resolve</code>的意思更接近于决议，而不是成功完成。</p>
<p><code>Promise.resolve</code>根据传入的参数不同会做不同的处理。</p>
<p>如果传入的是一个 Promise，Promise.resolve 会直接返回这个 Promise<br>如果传入的是包含 then 方法的对象，会使用 Promise 的构造函数创建一个新的 Promise，以 then 方法作为构造函数的参数<br>否则返回状态 fulfilled，值为 Promise.resolve 参数的 Promise</p>
<h3 id="then-方法"><a href="#then-方法" class="headerlink" title="then 方法"></a>then 方法</h3><p>Promise 最重要的方法是 then 方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">123</span>).then(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(val)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>then 方法接受两个参数，分别表示 fulfilled 和 rejected 状态下的执行函数<br>其中的 val 和 err 就是 Promise 在不同状态下的值。参数可以是普通函数，也可以箭头函数。</p>
<p>then 方法的两个参数都可以省略，如果不想传入第一个参数，可以传入 null 或者 undefined 等</p>
<p>then 方法返回一个 Promise，所以 Promise 可以一直串联下去</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">123</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(val) <span class="comment">// 123</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">456</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        val <span class="comment">// 456</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>then 方法第一个参数不仅可以返回数值和普通对象作为下一个 Promise 的值，还可以返回一个 Promise<br>如果返回的是一个 Promise，则 then 方法的状态和值取决于返回 Promise 的状态和值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">123</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="number">999</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="literal">null</span>, err =&gt; &#123;</span><br><span class="line">        err <span class="comment">// 999</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>如果 Promise 的值在 then 方法没有参数处理，则会一直像后传递。所以可以在 Promise 链的最后添加一个错误处理函数，处理之前所有 Promise 抛出的错误</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">123</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 不会被执行</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="literal">null</span>, err =&gt; &#123;</span><br><span class="line">        err <span class="comment">// 这里处理错误</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p><code>then</code>方法一个非常重要的特点是<code>then</code>的回调永远是异步的。准确来讲是在当前事件循环结束的微任务中执行。</p>
<h3 id="catch、Promise-all、Promise-race"><a href="#catch、Promise-all、Promise-race" class="headerlink" title="catch、Promise.all、Promise.race"></a>catch、Promise.all、Promise.race</h3><p>前例中在 Promise 链最后添加错误处理函数的情况十分普通，所以 es6 为 Promise 增加了 catch 方法。catch 方法等同于 then(null)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resovle(<span class="number">123</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure>
<p><code>Promise.all</code> 接受一个 Promise 数组，返回一个 Promise。数组的所有 Promsie 都变为 fulfilled 状态后，返回 Promise 的状态变为 fulfilled，值为数组所有 Promise 值的数组。其中任意一个 Promise 变为 rejected，返回 Promise 的状态变为 rejected。</p>
<p>Promise.race 同样返回一个 Promise，返回的 Promise 在任何一个 Promise 决议后决议，决议的结果就是返回 Promise 的结果。</p>
<h3 id="Promise-的问题"><a href="#Promise-的问题" class="headerlink" title="Promise 的问题"></a>Promise 的问题</h3><p>Promise 最大的问题在于会吞掉错误。即如果 Promise 内部抛出了错误，如果错误没有被 catch 方法处理，错误也不会冒泡到 Promise 外部。</p>
<p>这种设计的原因在于 Promise 被设计为在任何时候添加 then 方法都可以获取 Promise 决议的值。所以即使 Promise 内部报错了，引擎也不能确定将来是不是会存在一个 catch 方法来捕获这个错误，所以不能讲错误抛出。</p>
<p>这种设计有时候会导致 Promise 的异常被吞掉。所以最佳实践是永远在 Promise 链的最后添加一个 catch 方法。</p>
<p>在浏览器和 nodejs 中都有事件可以监听未捕获的 Promise 错误。</p>
<p>浏览器中的事件如下<br><code>unhandledrejection</code>,同一个事件循环中，Promise 被拒绝，没有提供拒绝处理程序时触发<br><code>rejectionhandled</code>,一个事件循环后，拒绝的 Promise 被处理时触发</p>
<p>nodejs 的事件与浏览器中基本一致，只是事件名是驼峰格式</p>
<h3 id="Promise-的实现"><a href="#Promise-的实现" class="headerlink" title="Promise 的实现"></a>Promise 的实现</h3><p>完全模拟实现 Promise 是不可能的，因为 Promise 的 then 虽然永远是异步的，但是在事件循环中 Promise 属于微任务，setTimeout 属于宏任务，所以无法完全模拟。</p>
<p>以下是一个 Promise 的模拟实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _status = <span class="built_in">Symbol</span>(<span class="string">'status'</span>)</span><br><span class="line"><span class="keyword">const</span> _value = <span class="built_in">Symbol</span>(<span class="string">'value'</span>)</span><br><span class="line"><span class="keyword">const</span> _fulfilledQueue = <span class="built_in">Symbol</span>(<span class="string">'fulfilledQueue'</span>)</span><br><span class="line"><span class="keyword">const</span> _rejectedQueue = <span class="built_in">Symbol</span>(<span class="string">'rejectedQueue'</span>)</span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="built_in">Symbol</span>(<span class="string">'pending'</span>)</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="built_in">Symbol</span>(<span class="string">'fulfilled'</span>)</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="built_in">Symbol</span>(<span class="string">'rejected'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(handler) &#123;</span><br><span class="line">        <span class="keyword">this</span>[_status] = PENDING</span><br><span class="line">        <span class="keyword">this</span>[_value] = <span class="string">''</span></span><br><span class="line">        <span class="keyword">this</span>[_fulfilledQueue] = []</span><br><span class="line">        <span class="keyword">this</span>[_rejectedQueue] = []</span><br><span class="line">        <span class="keyword">const</span> reject = <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>[_status] !== PENDING) <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">this</span>[_status] = REJECTED</span><br><span class="line">            <span class="keyword">this</span>[_value] = err</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> cb <span class="keyword">of</span> <span class="keyword">this</span>[_rejectedQueue]) &#123;</span><br><span class="line">                    cb(<span class="keyword">this</span>[_value])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> resolve = <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (val <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                val.then(resolve, reject)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>[_status] !== PENDING) <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">this</span>[_status] = FULFILLED</span><br><span class="line">            <span class="keyword">this</span>[_value] = val</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> cb <span class="keyword">of</span> <span class="keyword">this</span>[_fulfilledQueue]) &#123;</span><br><span class="line">                    cb(<span class="keyword">this</span>[_value])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            handler(resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="keyword">this</span>, &#123;</span><br><span class="line">            ownKeys(target) &#123;</span><br><span class="line">                <span class="keyword">const</span> notIncludedKeys = [_status, _value, _fulfilledQueue, _rejectedQueue]</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Reflect</span>.ownKeys(target).filter(<span class="function"><span class="params">key</span> =&gt;</span> !notIncludedKeys.includes(key))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> proxy</span><br><span class="line">    &#125;</span><br><span class="line">    then(onResolve, onRejected) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">nextResolve, nextReject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> _onResolve = <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">typeof</span> onResolve !== <span class="string">'function'</span>) &#123;</span><br><span class="line">                        nextResolve(val)</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">let</span> result = onResolve(val)</span><br><span class="line">                    <span class="keyword">if</span> (result <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                        result.then(nextResolve, nextReject)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        nextResolve(result)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    nextReject(error)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> _onReject = <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected !== <span class="string">'function'</span>) &#123;</span><br><span class="line">                        nextReject(err)</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">let</span> result = onRejected(err)</span><br><span class="line">                    <span class="keyword">if</span> (result <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                        result.then(nextResolve, nextReject)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        nextResolve(result)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    nextReject(error)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>[_status] === PENDING) &#123;</span><br><span class="line">                <span class="keyword">this</span>[_fulfilledQueue].push(_onResolve)</span><br><span class="line">                <span class="keyword">this</span>[_rejectedQueue].push(_onReject)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>[_status] === FULFILLED) &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    _onResolve(<span class="keyword">this</span>[_value])</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>[_status] === REJECTED) &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    _onReject(<span class="keyword">this</span>[_value])</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(handler) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">undefined</span>, handler)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span>(handler) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">            val =&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> MyPromise.resolve(handler()).then(<span class="function"><span class="params">()</span> =&gt;</span> val)</span><br><span class="line">            &#125;,</span><br><span class="line">            err =&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> MyPromise.resolve(handler()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> err</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> resolve(val) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(val))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> reject(err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(err))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> all(args) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> resolvedCount = <span class="number">0</span>,</span><br><span class="line">                resolveValueQueue = []</span><br><span class="line">            <span class="keyword">const</span> onResolved = <span class="function">(<span class="params">val, index</span>) =&gt;</span> &#123;</span><br><span class="line">                resolveValueQueue[index] = val</span><br><span class="line">                resolvedCount++</span><br><span class="line">                <span class="keyword">if</span> (resolvedCount == args.length) &#123;</span><br><span class="line">                    resolve(resolveValueQueue)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> onRejected = <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                reject(err)</span><br><span class="line">            &#125;</span><br><span class="line">            args.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">                MyPromise.resolve(item).then(<span class="function"><span class="params">val</span> =&gt;</span> onResolved(val, index), onRejected)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> race(args) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> onResolved = <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">                resolve(val)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> onRejected = <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                reject(err)</span><br><span class="line">            &#125;</span><br><span class="line">            args.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">                MyPromise.resolve(item).then(onResolved, onRejected)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> MyPromise</span><br></pre></td></tr></table></figure>
<p>整体思路是对状态的值的改变是同步，回调是异步，然后 then 方法的回调同样要异步(处理 FULFILLED 状态后添加的 then 方法)。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/28/basis/generator/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhen Huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/28/basis/generator/" itemprop="url">生成器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-28T19:52:57+08:00">
                2019-03-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h3 id="什么是生成器"><a href="#什么是生成器" class="headerlink" title="什么是生成器"></a>什么是生成器</h3><p>生成器是一个返回迭代器的函数。<br>不同于普通的函数，生成器在声明语法和执行上都差异极大。</p>
<p>以下是一个生成器的例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">say</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> x <span class="comment">// yield是生成器内的特殊语法，只能在生成器内出现</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一点需要注意，生成器返回的不仅仅是一个迭代器，也是一个可迭代对象，所以生成器的返回值可以直接使用<code>for...of</code>遍历</p>
<h5 id="生成器的声明"><a href="#生成器的声明" class="headerlink" title="生成器的声明"></a>生成器的声明</h5><p>不同于普通的函数生成，生成器的声明需要在<code>function</code>关键字和函数名之间加上<code>*</code>。</p>
<p>对于*、function 和函数名之间的位置关系，以下三种都可以</p>
<ol>
<li><code>function* say</code></li>
<li><code>function * say</code></li>
<li><code>function *say</code></li>
</ol>
<p>对于没有<code>function</code>关键字的方法声明，<code>*</code>号放在方法名之前即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    *say() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="生成器的执行"><a href="#生成器的执行" class="headerlink" title="生成器的执行"></a>生成器的执行</h5><p>作为函数，生成器也有返回值。不同于普通的函数，生成的返回值是一个可以调度生成器执行的迭代器。</p>
<p>以以下生成器为例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">say</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> gen = say()</span><br><span class="line">gen.next() <span class="comment">// 执行 yield 1</span></span><br><span class="line"><span class="comment">// gen.next()返回值 &#123;value:1,done:false&#125;</span></span><br><span class="line">gen.next() <span class="comment">// 执行 console.log(2) yield 2</span></span><br><span class="line"><span class="comment">// &#123;value:2,done:false&#125;</span></span><br><span class="line">gen.next() <span class="comment">// 执行 yield 3</span></span><br><span class="line"><span class="comment">// &#123;value:3,done:false&#125;</span></span><br><span class="line">gen.next()</span><br><span class="line"><span class="comment">// &#123;value:undefined,done:true&#125;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>生成器 say 执行后并不立即执行函数内部代码，而是返回一个迭代器，通过执行迭代器的 next 方法，可以让生成器继续执行。</li>
<li>每次调用迭代器的 next 方法，生成器会从上次暂停的地方开始执行，直到碰到下一个 yield 语句，或者函数结束。</li>
<li>如果碰到 yield 语句，生成器将 yield 后的值作为迭代器的 value 返回，然后函数暂停，等待下一次 next 方法调用。</li>
<li>如果函数结束(执行到最后一行或者碰到 return),将 return 的值作为 value 返回，此时 done 为 true</li>
</ol>
<h3 id="next-throw-return"><a href="#next-throw-return" class="headerlink" title="next/throw/return"></a>next/throw/return</h3><p>在迭代器中讲到过，迭代器必须有 next 方法，对于生成器返回的迭代器，除了 next 方法之外，还有 throw 和 return 方法</p>
<h5 id="next"><a href="#next" class="headerlink" title="next"></a>next</h5><p>生成器中 yield 表达式本身是没有值的，或者说值都是 undefined,可以通过跟 next 方法传值给 yield 表达式赋值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">NextValue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> gen = NextValue()</span><br><span class="line">gen.next()</span><br><span class="line"><span class="comment">// &#123;value:1,done:false&#125;</span></span><br><span class="line">gen.next(<span class="number">8</span>)</span><br><span class="line"><span class="comment">// &#123;value:8,done:false&#125;</span></span><br></pre></td></tr></table></figure>
<p>如上，第一次执行 next 返回 1<br>第二次执行 next 方法传入 8，8 会被赋值给 x,所以第二次 next 返回 8</p>
<p>next 的传值对于生成器十分重要，这意味着在生成器执行过程中，仍然可以通过给生成器传递不同值从而得到不同的结果</p>
<h5 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h5><p>通过 throw 方法可以在生成器内抛出一个错误，如果生成器内部没有捕获错误，错误会冒泡到生成器之外。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">ErrorGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> gen = ErrorGenerator()</span><br><span class="line">gen.throw(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错啦'</span>))</span><br><span class="line"><span class="comment">//  Uncaught Error: 出错啦</span></span><br></pre></td></tr></table></figure>
<h5 id="return"><a href="#return" class="headerlink" title="return"></a>return</h5><p>调用迭代器的 return 方法后，生成器会直接结束，返回的 value 为 return 的传入值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">ReturnGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> gen = ReturnGenerator()</span><br><span class="line">gen.return(<span class="number">3</span>)</span><br><span class="line"><span class="comment">// &#123;value:3,done:true&#125;</span></span><br><span class="line">gen.next(<span class="number">9</span>)</span><br><span class="line"><span class="comment">// &#123;value:undefined,done:true&#125;</span></span><br></pre></td></tr></table></figure>
<h5 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h5><p>方法 next/throw/return 都可以理解为将 yield 语句替换为一段其它语句，然后继续执行</p>
<ol>
<li>next 使用 next 方法的参数替换 yield 语句</li>
<li>throw 方法用 <code>throw</code>替换 yield 语句，throw 的值为 throw 方法的参数</li>
<li>return 使用<code>return</code>语句替换 yield 语句，return 的值为 return 方法的参数</li>
</ol>
<h3 id="yield"><a href="#yield" class="headerlink" title="yield*"></a>yield*</h3><p>在生成器内部可以使用<code>yield*</code>嵌套 yield 其它可迭代对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">NestedGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">Generator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="comment">// 也可以是等其它可迭代对象</span></span><br><span class="line">    <span class="keyword">yield</span>* NestedGenerator()</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> gen = Generator()</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> gen) &#123;</span><br><span class="line">    <span class="comment">//1 2 3 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>先看一个回调函数的异步例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ajax(<span class="string">'a/b/c'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    handle(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">123</span>)</span><br></pre></td></tr></table></figure>
<p>setTimeout 需要传入一个回调函数。回调函数的方式缺点很多，这里只指出生成器能解决的最重要的一条。</p>
<p>回调函数的执行顺序不符合直觉。</p>
<p>代码<code>handle(res)</code>位于<code>console.log(123)</code>之前，执行却在<code>console.log(123)</code>之后。</p>
<p>先看一下上面的代码用生成器执行应该怎么写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ajax(<span class="string">'a/b/c'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            it.throw(err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        it.next(res)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">runTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="keyword">yield</span> request()</span><br><span class="line">    handle(x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = runTask()</span><br><span class="line">it.next()</span><br></pre></td></tr></table></figure>
<p>第一眼的感觉这段代码比回调的复杂很多，而且也不是很好理解。</p>
<p>继续之前，先梳理下这段代码的逻辑</p>
<ol>
<li>it.next()执行了 request 方法</li>
<li>request 方法执行了一个异步方法 ajax(假设存在这样一个异步方法)</li>
<li>在异步方法的回调函数中调用了 it.next，传入了回调函数的返回值 res</li>
<li>res 被赋值给 x,handle(x)是真正处理 ajax 返回值的代码</li>
</ol>
<p>上例中处理异步的核心代码其实只有两行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="keyword">yield</span> request()</span><br><span class="line">handle(x)</span><br></pre></td></tr></table></figure>
<p>这两行代码独特的地方在于它完全没有涉及异步、回调。就好像这是一个同步调用一样。</p>
<p>当然，上面的代码过于麻烦，而且硬编码严重，不具有通用性，可以改造如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改造后的生成器异步代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">tasks</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> it = tasks(),</span><br><span class="line">        result = it.next()</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (result.done) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> result.value === <span class="string">'function'</span>) &#123;</span><br><span class="line">            result.value(<span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                    it.throw(err)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                result = it.next(res)</span><br><span class="line">                step()</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = it.next(result.value)</span><br><span class="line">            step()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    step()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        ajax(<span class="string">'a/b/c'</span>, callback)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="keyword">yield</span> request()</span><br><span class="line">    handle(x)</span><br><span class="line">&#125;</span><br><span class="line">run(main)</span><br></pre></td></tr></table></figure>
<p>改造后的代码更加复杂了，但是通用性更强。<code>run</code>方法完全通用，<code>request</code>方法可以用一个工厂方法生成。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestFactory</span>(<span class="params">func, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        func(...args, callback)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改后的<code>request</code>方法如下所示</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改前</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        ajax(<span class="string">'a/b/c'</span>, callback)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="keyword">yield</span> request()</span><br><span class="line">    handle(x)</span><br><span class="line">&#125;</span><br><span class="line">run(main)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestFactory</span>(<span class="params">func, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        func(...args, callback)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="keyword">yield</span> requestFactory(ajax, <span class="string">'a/b/c'</span>)</span><br><span class="line">    handle(x)</span><br><span class="line">&#125;</span><br><span class="line">run(main)</span><br></pre></td></tr></table></figure>
<p>至此，<code>run</code>和<code>requestFactory</code>都成了通用方法，真正的执行代码只有生成器<code>main</code>方法和<code>run(main)</code>语句。</p>
<p>在上面的<code>run</code>方法中，我们一直有一个假设，即<code>ajax</code>异步方法接收的回调是 error-first 风格的。写出这样风格的异步方法不难，但是也总是难免会存在不是这种风格的回调。但要在<code>run</code>方法中判断回调的第一个参数是不是错误很难，或者说不可能。<br>所以对于<code>run</code>方法的回调方法的参数必须有所约定，<code>Promise</code>是最好的选择。即<code>requestFactory</code>方法需要返回一个 Promise,或者 ajax 方法直接返回<code>Promise</code></p>
<p>最终的代码如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">tasks</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> it = tasks(),</span><br><span class="line">        result = it.next()</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (result.done) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> (result.value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">            result.value.then(</span><br><span class="line">                res =&gt; &#123;</span><br><span class="line">                    result = it.next(res)</span><br><span class="line">                    step()</span><br><span class="line">                &#125;,</span><br><span class="line">                err =&gt; &#123;</span><br><span class="line">                    it.throw(err)</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = it.next(result.value)</span><br><span class="line">            step()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    step()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="keyword">yield</span> ajax(<span class="string">'a/b/c'</span>) <span class="comment">// ajax需要返回一个Promise</span></span><br><span class="line">    handle(x)</span><br><span class="line">&#125;</span><br><span class="line">run(main)</span><br></pre></td></tr></table></figure>
<p>其中<code>run</code>方法可以封装为一个工具函数。</p>
<p>es7 将这种异步方式规范化了。没错，就是<code>async await</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/25/basis/iterator/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhen Huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/25/basis/iterator/" itemprop="url">迭代器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-25T20:29:15+08:00">
                2019-03-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h3 id="什么是迭代器"><a href="#什么是迭代器" class="headerlink" title="什么是迭代器"></a>什么是迭代器</h3><p>在 js 中，遍历数组的一种常用方式是通过<code>index</code>，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    arr[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这也是 es6 之前遍历类数组结构的常用方法。<br>es6 中引入了两种新的数据结构，<code>Set</code>和<code>Map</code>。对于<code>Set</code>和<code>Map</code>，不能通过下标访问元素，所以遍历 Set 和 Map 需要一种新的方法，最好这种方法还能够和类数组结构兼容。<br>所以 es6 定义了一种新的遍历方式<code>for...of</code>。而<code>for...of</code>的遍历正是通过迭代器来实现。</p>
<p><strong>迭代器是一个普通对象</strong>，必须包含<code>next</code>方法，可以包含<code>return/throw</code>方法。<br>执行迭代器的<code>next</code>方法返回一个对象，包含两个属性<code>value、done</code>，其中<code>value</code>表示值,<code>done</code>表示遍历是否结束。<br>在遍历结束之前，<code>done</code>都会返回<code>false</code>。<code>done</code>返回<code>true</code>则代表遍历结束。</p>
<p>下面是一个简单的迭代器示例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> iteratorExmaple = &#123;</span><br><span class="line">    next() &#123;</span><br><span class="line">        <span class="keyword">if</span> (i++ &lt;= 5) &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                value: i,</span><br><span class="line">                done: false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;</span><br><span class="line">            value: i,</span><br><span class="line">            done: true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在循环<code>for(let item of arr)</code>中，<code>for...of</code>循环会调用 arr 迭代器的<code>next</code>方法，把<code>value</code>的值赋给<code>item</code>，直到<code>next</code>方法返回的对象<code>done</code>为 true。(arr 的迭代器从何而来，后面会讲到)<br>注意：<strong>done 为 true 时的 value 值不会包含在 for…of 循环中</strong></p>
<h3 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h3><p>js 中有很多类型都是可迭代对象，包括数组、类数组结构如 NodeList,arguments、字符串、Set、Map。<br>普通对象不是。</p>
<p>迭代器也不是，迭代器不能被<code>for...of</code>循环遍历。</p>
<p>一个对象是不是可迭代对象取决于对象是不是包含<code>Symbol.iterator</code>方法。<code>Symbol.iterator</code>方法需要返回一个迭代器，<code>for...of</code>遍历基于这个迭代器循环遍历。<br>所以可以通过以下方式让一个普通对象也可以<code>for...of</code>遍历</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            i: <span class="number">0</span>,</span><br><span class="line">            next() &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.i++ &lt; 5) &#123;</span><br><span class="line">                    return &#123;</span><br><span class="line">                        value: this.i,</span><br><span class="line">                        done: false</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                return &#123;</span><br><span class="line">                    done: true</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">for (let item of obj) &#123;</span><br><span class="line">    console.log(item) // 1 2 3 4 5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内建的可迭代对象默认拥有<code>Symbol.iterator</code>属性，一般都位于对象的原型上，所以都可以通过<code>for...of</code>遍历。</p>
<p>诸如<code>Set.keys()</code>方法返回的是迭代器，但是其可以被<code>for...of</code>遍历不是因为是迭代器，而是这个迭代器包含<code>Symbol.iterator</code>属性。</p>
<p>重要的事情说三遍:<br><strong>迭代器不是可迭代对象，不能被<code>for...of</code>循环遍历</strong></p>
<h3 id="使用迭代器的其它场合"><a href="#使用迭代器的其它场合" class="headerlink" title="使用迭代器的其它场合"></a>使用迭代器的其它场合</h3><p>虽然上面的例子中一直以<code>for...of</code>为迭代器的使用例子，但是还有一些其它情况也会调用迭代器接口</p>
<ol>
<li>展开运算符 <code>...</code></li>
<li>yield * 。生成器的内部方法，具体参考生成器。</li>
<li>Array.from()</li>
</ol>
<p>还有一些其它场合，基本上 es6 之后新的遍历都会使用迭代器</p>
<h3 id="内建迭代器"><a href="#内建迭代器" class="headerlink" title="内建迭代器"></a>内建迭代器</h3><p>js 中,Array、Set、Map 都包含有内建的迭代器 entries(),values(),keys()</p>
<p>其中 keys 返回键的迭代器，但是仍然可以被 for…of 遍历，因为 keys 返回的也是一个可迭代对象。values()和 entries()也类似<br>values()返回值的迭代器<br>entries()返回键值对数组的迭代器</p>
<h3 id="迭代器的高级用法"><a href="#迭代器的高级用法" class="headerlink" title="迭代器的高级用法"></a>迭代器的高级用法</h3><p>迭代器的高级用法，如迭代器的 throw 方法，迭代器 next 方法传参，几乎都与生成器相关。所以放在生成器中一起讲。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/19/basis/type-cast/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhen Huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/19/basis/type-cast/" itemprop="url">类型转换</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-19T20:57:14+08:00">
                2019-03-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h3><p>Number Boolean String Object</p>
<h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h3><h3 id="装箱转换-拆箱转换"><a href="#装箱转换-拆箱转换" class="headerlink" title="装箱转换/拆箱转换"></a>装箱转换/拆箱转换</h3><h3 id="抽象转换-ToNumber-ToString-ToPrimitive-ToBoolean"><a href="#抽象转换-ToNumber-ToString-ToPrimitive-ToBoolean" class="headerlink" title="抽象转换 ToNumber ToString ToPrimitive ToBoolean"></a>抽象转换 ToNumber ToString ToPrimitive ToBoolean</h3><p><code>ToNumber ToString</code> 只是 <code>ToPrimitive</code>的一种情况<br><code>ToBoolean</code> 不属于其中，有一套独立的规则<br><code>ToPrimitive</code>可以理解为就是<code>Symbol.toPrimitive</code>函数的结果</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.toPrimitive](hint) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (hint) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'default'</span>:</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'default'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'string'</span>:</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'string'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'number'</span>:</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'number'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">console</span>.log(hint)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'toString'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">    &#125;,</span><br><span class="line">    valueOf() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'valueOf'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">6</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Number</span>(obj) <span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">String</span>(obj) <span class="comment">// 2</span></span><br><span class="line">    obj + <span class="number">1</span> <span class="comment">// 1+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Symbol.toPrimitive</code>传入的<code>hint</code>只有<code>string/number/default</code>三种情况，<code>default</code>只是为了代码完备。<br><code>Symbol.toPrimitive</code>的返回结果就是<code>Number(obj)</code>等的返回结果,如果返回的不是<code>hint</code>的基本类型，会强制转换为<code>hint</code>类型(可能会失败，如<code>Symbol</code>转数字)，如果返回的是对象，会抛出错误。<br><code>toString</code>和<code>valueOf</code>方法不会执行。</p>
<p>默认<code>Symbol.toPrimitive</code>情况下，根据不同的<code>hint</code>,会先后调用<code>valueOf</code>和<code>toString</code>，只要有一个返回基本类型，就会将该基本类型强制转换为<code>hint</code>类型，如果两者都返回对象，报错。至于调用的先后顺序，<code>string</code>是<code>toString-valueOf</code>，<code>number</code>相反，<code>default</code>在<code>Date</code>对象中是<code>toString</code>优先，其它是<code>valueOf</code>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/19/basis/set-map/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhen Huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/19/basis/set-map/" itemprop="url">Set和Map</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-19T19:24:25+08:00">
                2019-03-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set 是 es6 定义的一种新的数据结构，概念上与数组很类似，但是操作上与数组截然不同。</p>
<p>Set 最重要的特性是<strong>不包含重复元素</strong>，如果不需要这种特性，一般没有使用 Set 的需要。Set 内部使用<code>Object.is</code>来比较两个元素是否相等，而不是<code>===</code>,<code>Object.is</code>和<code>===</code>的区别在于<code>NaN</code>和自己相等以及<code>-0</code>和<code>+0</code>不相等。</p>
<h5 id="创建-Set"><a href="#创建-Set" class="headerlink" title="创建 Set"></a>创建 Set</h5><p>创建 Set 只能使用构造函数的方式<code>new Set()</code>。也可以传入<code>iterable</code>对象，Set 会将迭代对象去重。如果传入的内容不能迭代，会抛出错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>]) <span class="comment">// set([1,2,4])</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>(<span class="number">3</span>) <span class="comment">// error 3 is not iterable</span></span><br></pre></td></tr></table></figure>
<h5 id="操作-Set"><a href="#操作-Set" class="headerlink" title="操作 Set"></a>操作 Set</h5><p>Set<strong>不是</strong>数组，不能够通过索引直接获取某个位置的值。<br>操作数组的方法包括</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">add()</td>
<td style="text-align:center">添加值</td>
</tr>
<tr>
<td style="text-align:center">delete()</td>
<td style="text-align:center">删除值</td>
</tr>
<tr>
<td style="text-align:center">has()</td>
<td style="text-align:center">是否包含某个值</td>
</tr>
<tr>
<td style="text-align:center">clear()</td>
<td style="text-align:center">清空 Set</td>
</tr>
<tr>
<td style="text-align:center">size</td>
<td style="text-align:center">Set 的值个数</td>
</tr>
</tbody>
</table>
<p>由于<code>add</code>方法返回Set本身，对于连续添加多个元素可以采用如下方式<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">set.add(<span class="number">1</span>).add(<span class="number">2</span>).add(<span class="number">3</span>)</span><br></pre></td></tr></table></figure></p>
<p>Set 还包含<code>forEach</code>方法。但是由于 Set 没有索引，<code>forEach</code>的<code>key</code>和<code>value</code>相同，所以几乎没有任何理由使用<code>forEach</code>。同理，<code>set.keys()/set.values()/set.entries()</code>也毫无意义。遍历 Set 最好的方式是使用<code>for...of</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> s) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，Set 唯一的作用是否就是确认是否包含某个变量，但是这个功能数组也能轻易做到，<code>arr.includes()</code>和<code>set.has()</code>功能相同。<br>ps:和<code>arr.indexOf()</code>有一点区别,<code>indexOf</code>使用<code>===</code>判别是不是同一个元素,<code>includes</code>使用<code>Object.is()</code>，所以数组的<code>includes</code>和<code>indexOf</code>还是有一点区别的</p>
<p>Set 唯一的作用大概是用来去重</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">[...new <span class="built_in">Set</span>(arr)] <span class="comment">// [1,2,3,4]</span></span><br></pre></td></tr></table></figure>
<p>除此之外，似乎没有其他用途了</p>
<h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><p>WeakSet 正如其名，与 Set 基本相同，区别有两点</p>
<ol>
<li>WeakSet 只能包含对象，不能包含基本类型，给 WeakSet 添加基本类型会报错</li>
<li>WeakSet 不是可遍历对象，不包含<code>clear()</code>和<code>size</code>方法/属性</li>
</ol>
<p>所以 WeakSet 只有三个方法<code>add/has/delete</code></p>
<p>WeakSet 最大的特点是只会保存持有对象的弱引用。即如果 WeakSet 持有的对象不被其他变量引用，则该对象可以被回收。<br>个人对WeakSet的用途暂只限于判断对象是否被回收。直接<code>console.log(weakset)</code>可以判断<code>WeakSet</code>包含的变量是否被回收。（不被引用的变量不一定马上被回收，这种方法判断依赖回收机制的触发，需要一定时间差）</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map 和 Set 经常被一起提及，但是两者其实没什么关联。除了语法上的类似外，唯一是关系大概是都是 es6 添加的新数据结构。</p>
<p>如果说 Set 是参照数组创建的，Map 是参照对象创建的。Map也是键值对的组合，与对象的区别在于对象的<code>key</code>只能是字符串，而Map的<code>key</code>可以是任意数据类型</p>
<h5 id="创建-Map"><a href="#创建-Map" class="headerlink" title="创建 Map"></a>创建 Map</h5><p>创建 Map 也只能通过<code>new Map()</code>的方式。如果要给Map传入初始值，可以传入每个元素都是数组的数组<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'key'</span>,<span class="string">'value'</span>],[<span class="number">1</span>,&#123;&#125;]])</span><br></pre></td></tr></table></figure></p>
<h5 id="操作Map"><a href="#操作Map" class="headerlink" title="操作Map"></a>操作Map</h5><p>Map不能通过属性名<code>.</code>或者<code>[]</code>语法直接访问属性。Map的操作方法和Set及其相似。</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">set(key,val)</td>
<td style="text-align:center">添加/更新key的值为val</td>
</tr>
<tr>
<td style="text-align:center">get(key)</td>
<td style="text-align:center">获取key的val</td>
</tr>
<tr>
<td style="text-align:center">delete(key)</td>
<td style="text-align:center">删除key</td>
</tr>
<tr>
<td style="text-align:center">has(key)</td>
<td style="text-align:center">是否包含key</td>
</tr>
<tr>
<td style="text-align:center">clear()</td>
<td style="text-align:center">清空 Map</td>
</tr>
<tr>
<td style="text-align:center">size</td>
<td style="text-align:center">Map的键值对数量</td>
</tr>
</tbody>
</table>
<p>除了<code>add</code>方法变成了<code>set/get</code>，其它的方法完全一样。Map同样是<code>iterable</code>对象，支持<code>iterable</code>的所有遍历方式。<br>Map的get方法返回Map本身，同样可以采用链式方式添加多个元素<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="number">1</span>,<span class="number">1111</span>).set(<span class="number">2</span>,<span class="number">2222</span>)</span><br></pre></td></tr></table></figure></p>
<p>Map最大的作用在于<code>key</code>可以不是字符串，在需要使用非字符串<code>key</code>时，如<code>Symbol</code>，Map还是很有作用的。</p>
<h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><p>WeakMap是Map的弱引用版本，与WeakSet类似</p>
<ol>
<li>WeakMap的<code>key</code>只能是对象</li>
<li>WeakMap不是可遍历对象</li>
</ol>
<p>WeakMap的<code>key</code>也是弱引用，即如果WeakMap的<code>key</code>不再被其它变量引用，WeakMap的<code>key</code>可以被回收。<br>WeakMap的<code>value</code>是强引用，即只要WeakMap的<code>key</code>存在，WeakMap的<code>value</code>就不会被回收。</p>
<p>与WeakSet类似，WeakMap只支持<code>set/get/delete/has</code>四个方法</p>
<p>WeakMap一个很常用的应用场景是给页面上的元素添加对应值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> el = <span class="built_in">document</span>.querySelector(<span class="string">'#xiaogou'</span>),</span><br><span class="line">    m = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    m.set(el,&#123;</span><br><span class="line">        id:<span class="string">'xiaogou'</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>在不使用Map的情况下，如果元素<code>#xiaogou</code>被删除，对象<code>{id:&#39;xiaogou&#39;}</code>很难被回收，只能在元素被移除时通过事件触发来处理，而且这种处理也不够准确，因为元素仍然可能被重新添加会<code>DOM</code>中。而WeakMap几乎可以完美的解决这个问题。</p>
<p>还有类似场景是私有变量的处理。具体代码就不列出了。<br>WeakMap的使用场景一般在需要为对象保存关联信息，对象删除时可以自动删除关联信息。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/14/basis/symbol/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhen Huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/14/basis/symbol/" itemprop="url">symbol</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-14T19:09:41+08:00">
                2019-03-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h3 id="什么是-Symbol"><a href="#什么是-Symbol" class="headerlink" title="什么是 Symbol"></a>什么是 Symbol</h3><p><code>Symbol</code>是 js 中第 7 种数据类型，第 6 种基本类型。Symbol 的主要目的是取代 js 中的魔法字符串。因为传统的对象属性只能是字符串，很容易被意外的覆盖，而 Symbol 类型的值都是独一无二的，可以有效防止意外修改对象属性的问题。</p>
<p>检测是否是 Symbol 可以用<code>typeof</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> sy === <span class="string">'symbol'</span></span><br></pre></td></tr></table></figure>
<h3 id="创建-Symbol"><a href="#创建-Symbol" class="headerlink" title="创建 Symbol"></a>创建 Symbol</h3><p><code>Symbol</code>是一种基本类型，没有构造函数，不能通过<code>new Symbol()</code>的方式创建。创建<code>Symbol</code>的方式有两种。<br>一种是通过<code>Symbol()</code>方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sy = <span class="built_in">Symbol</span>(<span class="string">'description'</span>),</span><br><span class="line">    sy2 = <span class="built_in">Symbol</span>(<span class="string">'description'</span>)</span><br><span class="line">sy === sy2 <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>其中<code>description</code>只是用于描述创建的 Symbol，对 Symbol 的值没有任何影响，创建两个 Symbol 传入相同的 description 得到的是不同的 Symbol。</p>
<p>第二种创建 Symbol 的方式是通过<code>Symbol.for()</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sy = <span class="built_in">Symbol</span>.for(<span class="string">'description'</span>),</span><br><span class="line">    sy2 = <span class="built_in">Symbol</span>.for(<span class="string">'description'</span>)</span><br><span class="line">sy === sy2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>其中的<code>description</code>既是 Symbol 的标识符，也是描述。<code>Symbol.for()</code>会先查找是否存在相同标识符的 Symbol,如果存在就返回，如果不存在就创建一个新的 Symbol。<br>注意：只有<code>Symbol.for()</code>创建的 Symbol 才会有标识符，<code>Symbol()</code>创建的 Symbol 没有标识符。所以</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sy = <span class="built_in">Symbol</span>(<span class="string">'123'</span>),</span><br><span class="line">    sy2 = <span class="built_in">Symbol</span>.for(<span class="string">'123'</span>)</span><br><span class="line">sy === sy2 <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="操作-Symbol"><a href="#操作-Symbol" class="headerlink" title="操作 Symbol"></a>操作 Symbol</h3><p>Symbol 没有对应的内置对象类型，所以 Symbol 实例没有额外的方法，几乎不能执行任何操作。除了<code>Object.prototype</code>上的<code>toString</code>等几个方法外，Symbol 还有一个<code>Symbol.keyFor()</code>方法，用于获取 Symbol 的标识符</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sy = <span class="built_in">Symbol</span>(<span class="string">'123'</span>),</span><br><span class="line">    sy2 = <span class="built_in">Symbol</span>.for(<span class="string">'123'</span>)</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(sy) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(sy2) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>
<h3 id="内置-Symbol-值"><a href="#内置-Symbol-值" class="headerlink" title="内置 Symbol 值"></a>内置 Symbol 值</h3><p>js 有一些行为一直是编译器内部在控制，代码无法影响的。而现在 js 通过一些预先定义好的 Symbol 属性将其暴露了出来。</p>
<ol>
<li>Symbol.hasInstance</li>
<li>Symbol.isConcatSpreadable</li>
<li>Symbol.iterator</li>
<li>Symbol.species</li>
<li>Symbol.toPrimitive</li>
<li>Symbol.toStringTag</li>
<li>Symbol.match</li>
<li>Symbol.search</li>
<li>Symbol.replace</li>
<li>Symbol.split</li>
<li>Symbol.unscopables</li>
</ol>
<h5 id="Symbol-hasInstance"><a href="#Symbol-hasInstance" class="headerlink" title="Symbol.hasInstance"></a>Symbol.hasInstance</h5><p>用于<code>a instanceof Func</code>时，此时会调用<code>Func[Symbol.hasInstance]</code>方法，方法的返回值就是<code>instanceof</code>的结果。<code>Symbol.hasInstance</code>定义在<code>Function.prototype</code>上，是一个不可遍历，不可修改，不可配置的属性。要修改<code>instanceof</code>默认行为需要使用如下方式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Name</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Name, <span class="built_in">Symbol</span>.hasInstance, &#123;</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，由于不可写属性的限制，不能采用如下方式</span></span><br><span class="line">Name[<span class="built_in">Symbol</span>.hasInstance] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Symbol-isConcatSpreadable"><a href="#Symbol-isConcatSpreadable" class="headerlink" title="Symbol.isConcatSpreadable"></a>Symbol.isConcatSpreadable</h5><p>调用<code>arr.concat(obj)</code>方法时，如果<code>obj</code>的<code>Symbol.isConcatSpreadable</code>为<code>true</code>，那么<code>obj</code>的前<code>length</code>个数字属性会被添加到<code>arr</code>中，非数字属性则会被丢弃。如果是<code>false</code>，<code>obj</code>会被直接添加到<code>arr</code>中。<br>注意：数字属性只会取<code>0 - length-1</code></p>
<p>默认情况下，任何对象都没有<code>Symbol.isConcatSpreadable</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    obj = &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">4</span>,</span><br><span class="line">        <span class="number">3</span>: <span class="number">5</span>,</span><br><span class="line">        a: <span class="string">'xiaogou'</span>,</span><br><span class="line">        length: <span class="number">2</span>,</span><br><span class="line">        [<span class="built_in">Symbol</span>.isConcatSpreadable]: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">arr.concat(obj) <span class="comment">// [1,2,3,4,empty]</span></span><br></pre></td></tr></table></figure>
<h5 id="Symbol-iterator"><a href="#Symbol-iterator" class="headerlink" title="Symbol.iterator"></a>Symbol.iterator</h5><p>用于<code>for...of</code>循环。可迭代对象都包含这个属性。<br><code>Symbol.iterator</code>是一个函数，需要返回一个<code>迭代器</code>。关于什么是迭代器，详见迭代器与生成器。<br>简单讲，迭代器就是包含<code>next()</code>方法属性的对象，每次调用<code>next()</code>方法时，都会返回一个<code>{value,done}</code>的对象,当<code>done</code>为 true 时，迭代器终止。</p>
<p><code>for...of</code>遍历时，实际上是遍历<code>Symbol.iterator()</code>返回的迭代器。</p>
<p>对象不可迭代的普通对象，可以通过添加<code>Symbol.iterator</code>方法来使其可以迭代。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            next() &#123;</span><br><span class="line">                <span class="keyword">if</span> (i++ &lt; 3) &#123;</span><br><span class="line">                    return &#123; value: i, done: false &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return &#123; done: true &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">for (let i of obj) &#123;</span><br><span class="line">    console.log(i)</span><br><span class="line">&#125;</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br><span class="line">// 4</span><br></pre></td></tr></table></figure>
<p>普通对象原本是不可以用于<code>for...of</code>循环的，通过添加<code>Symbol.iteraotr</code>方法，可使其可以通过<code>for...of</code>循环遍历。同理也可以用于数组的展开运算符。</p>
<p>虽然上例中使用的是普通函数，但是更普遍的做法可能是为<code>Symbol.iterator</code>函数赋一个生成器函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然形式不一样，但是与<code>Symbol.iterator</code>关系不大，主要还是生成器。这里就不展开了。</p>
<h5 id="Symbol-species"><a href="#Symbol-species" class="headerlink" title="Symbol.species"></a>Symbol.species</h5><p>内建对象实例方法返回新的实例时使用。比如 Array 的<code>slice</code>方法会返回一个新的 Array，如果通过 es6 extends 继承 Array，slice 方法会默认返回子类型的实例。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> MyArray(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),</span><br><span class="line">    b = a.slice(<span class="number">1</span>)</span><br><span class="line">b <span class="keyword">instanceof</span> MyArray <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>因为Array的<code>Symbol.species</code>默认指向this，所以返回MyArray类型的实例。<br>注意:<code>Symbol.species</code>定义为Array的静态属性，所以this指向实例的构造函数本身</p>
<p>通过指定<code>Symbol.species</code>可以返回一个其他类型的实例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species] ()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span> <span class="comment">// 也可以指定为其他值，比如MyClass</span></span><br><span class="line">    &#125;</span><br><span class="line">    clone()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">this</span>.constructor[<span class="built_in">Symbol</span>.species]()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用<code>Symbol.species</code>的内建类型有 Array, ArrayBuffer, Map, Set, Typed arrays, Promise, RegExp</p>
<h5 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a>Symbol.toPrimitive</h5><p>用于变量的类型转换。在做类型转换或者获取对象的原始值时，会调用此方法。如<code>&#39;&#39;+a</code>会调用<code>a</code>的<code>Symbol[toPrimitive]</code>方法。</p>
<p>方法接受一个参数<code>hint</code>，可能的值有<code>string、number、default</code>。表示当前转换采用的模式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.toPrimitive]: <span class="function"><span class="keyword">function</span>(<span class="params">hint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (hint) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'string'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">'string'</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'number'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">'number'</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'default'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">'default'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然可以为<code>string、number、default</code>指定不同的返回值，但是一般还是给<code>default</code>指定为<code>string、number</code>中的一个<br><code>string</code>与<code>number</code>模式比较好理解,<code>default</code>模式只会出现在下列三种情况</p>
<ol>
<li>==</li>
<li>+号运算符</li>
<li>给 Date 构造函数传递一个参数</li>
</ol>
<h5 id="Symbol-toStringTag"><a href="#Symbol-toStringTag" class="headerlink" title="Symbol.toStringTag"></a>Symbol.toStringTag</h5><p>js 中一直有一个识别类型的方法<code>Object.prototype.toString.call(obj)</code>，返回值<code>[object XXX]</code>，对于不同类型的对象,<code>XXX</code>各有不同。对于<code>Array</code>是<code>Array</code>，对于自定义对象，是<code>Object</code>。而<code>XXX</code>可以通过<code>Symbol.toStringTag</code>修改。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">name.prototype[<span class="built_in">Symbol</span>.toStringTag] = <span class="string">'name'</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> name())</span><br></pre></td></tr></table></figure>
<p>没错,<code>Symbol.toStringTag</code>的值是一个字符串，<strong>不是函数</strong></p>
<h5 id="Symbol-search"><a href="#Symbol-search" class="headerlink" title="Symbol.search"></a>Symbol.search</h5><p><code>Symbol.search、Symbol.match</code>等四个方法都是定义在<code>Regrex.prototype</code>上，是调用字符串方法<code>str.search(regex)、str.match(regex)</code>时调用的方法,所以<code>str.search(regex)</code>实际上调用的是<code>regex[Symbol.search](str)</code></p>
<p>这 4 个方法都接受字符串作为参数。<br>实际上，完全可以为一个对象定义这四个方法，然后当做正则表达式使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.search]: <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">'123'</span>.search(obj) <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/14/basis/animation/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhen Huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/14/basis/animation/" itemprop="url">动画</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-14T18:02:05+08:00">
                2019-03-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>js 动画和 css 动画的区别<br>GPU 加速和硬件加速是不是同一个东西<br>willchange 有何用，属性不同的值有什么区别</p>
<h3 id="硬件加速"><a href="#硬件加速" class="headerlink" title="硬件加速"></a>硬件加速</h3><p>所谓的硬件加速，在浏览器中来讲就是使用 GPU 渲染，在 compositor thread 中直接渲染，不通过 main thread，不触发 relayout 和 repaint。</p>
<p>GPU 渲染会生成一个单独的<code>composite layer</code>，然后重排像素的位置，而不是重新绘制，所以如果使用了不能通过重排像素实现的属性，不如<code>background</code>，GPU 渲染带来的优势就会消失</p>
<p>会生成单独<code>composite layer</code>的情况包括</p>
<ol>
<li>transform 3d 或者 perspective</li>
<li>video or canvas</li>
<li>使用 css filters</li>
<li>一个覆盖在其它<code>composite layer</code>上的元素</li>
</ol>
<p>通过 chrome 开发者工具<code>more tools</code>中的<code>layers</code>可以查看页面的<code>composite layer</code></p>
<p>不是所有属性都会直接在<code>composite layer</code>中完成，只有以下属性会</p>
<ol>
<li>transform</li>
<li>opacity</li>
<li>filter</li>
</ol>
<p>注意：opacity 虽然会在 GPU 中直接完成，但是在改变之前并不会生成<code>composite layer</code>。而<code>transform 3d</code>才会直接生成<code>composite layer</code>，但是所有的<code>transform</code>变化都会在 GPU 中直接完成</p>
<p>所以，如果是<code>transform 2d</code>动画，在动画的开始和结束会各有一次<code>repaint</code></p>
<p>如果在动画开始前就给元素设置<code>transform:translateZ(0)</code>，会直接生成<code>composite layer</code>，动画过程中不会有任何<code>repaint</code><br>但是<code>transofrm:translateZ(0)</code>或者其他类似方式毕竟是 hack 类型的，所以 css 提出了新的属性<code>will-change</code><br><code>will-change</code>应该不仅仅创建一个<code>composite layer</code>，但从动画的角度来看，可以这样认为。<br><code>will-change</code>的使用有几点需要注意：</p>
<ol>
<li>尽量不要使用。和硬件加速一样，会有额外的内存消耗，尤其在移动设备上。</li>
<li>使用完成后需要移除。</li>
<li>在属性变化之前加上，否则毫无意义。</li>
<li>不要给 will-change 添加太多属性，易燃易爆炸</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/13/engineer/npm-publish/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhen Huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/13/engineer/npm-publish/" itemprop="url">发布npm包</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-13T11:41:05+08:00">
                2019-03-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="main-module字段"><a href="#main-module字段" class="headerlink" title="main/module字段"></a>main/module字段</h3><p>main字段用于指定导入模块时指定的文件<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main用于指定require('chalk')访问的文件</span></span><br><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">'chalk'</span>)</span><br></pre></td></tr></table></figure></p>
<p>module也用于指定导入模块时指定的文件，但这个不是package.json的官方字段，用于支持es6模块的环境<br>module字段一般指定使用es6模块打包的文件，而main指向用commonjs规范打包的文件，而不支持es6模块的环境不会查找module字段<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module 用于指定以es6方式引入包时的文件</span></span><br><span class="line"><span class="keyword">import</span> chalk <span class="keyword">from</span> <span class="string">'chalk'</span></span><br></pre></td></tr></table></figure></p>
<h3 id="bin-注册指令"><a href="#bin-注册指令" class="headerlink" title="bin 注册指令"></a>bin 注册指令</h3><p>npm包有时候需要注册指令，比如<code>@vue/cli</code>会注册<code>vue</code>指令，这样全局安装<code>@vue/cli</code>之后就可以在任意地方使用<code>vue</code>指令，<code>npm</code>也是以这种方式注册的指令，只是在node安装时就已经默认安装。<code>webpack</code>指令一般会局部注册，这样可以在<code>package.json</code>的<code>scripts</code>中使用。<br>注册指令需要在<code>package.json</code>中增加<code>bin</code>属性<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// in package.json</span><br><span class="line">"bin":&#123;</span><br><span class="line">    "vue":"bin/index.js"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>webpack</code>是要注册的指令，<code>bin/index.js</code>是指定的执行文件路径。指令最好使用npm包名本身，以免与其它指令冲突</p>
<p>在指定的执行文件路径中，<strong>必须</strong>在第一行加上以下代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br></pre></td></tr></table></figure></p>
<p>否则注册的指令无法正常执行，<a href="https://zh.wikipedia.org/wiki/Shebang" target="_blank" rel="noopener">原理参考这里</a></p>
<blockquote>
<p>未完待续</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/13/engineer/webpack-hot/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhen Huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/13/engineer/webpack-hot/" itemprop="url">webpack nodejs api热加载</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-13T11:21:31+08:00">
                2019-03-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="webpack-nodejs-api如何实现热加载"><a href="#webpack-nodejs-api如何实现热加载" class="headerlink" title="webpack nodejs api如何实现热加载"></a>webpack nodejs api如何实现热加载</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="keyword">const</span> webpackDevServer = <span class="built_in">require</span>(<span class="string">'webpack-dev-server'</span>)</span><br><span class="line">webpackDevServer(webpack(webpackConfig),devConfig)</span><br></pre></td></tr></table></figure>
<p>这是webpack-dev-server使用nodejs api调用的<a href="https://github.com/webpack/webpack-dev-server/blob/master/examples/api/simple/server.js" target="_blank" rel="noopener">例子</a>,要实现热加载，webpackConfig的entry必须包含下面两个入口。devConfig的hot应该要设置为true。(没确认过)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// localhost:8080是打开的ip和端口，去掉也可以</span></span><br><span class="line"><span class="string">'webpack-dev-server/client?http://localhost:8080'</span></span><br><span class="line"><span class="comment">// 这个还有其他选项 'webpack/hot/only-dev-server'，具体区别尚不明确。</span></span><br><span class="line"><span class="string">'webpack/hot/dev-server'</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>未完待续</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/05/basis/array-typed/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhen Huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/05/basis/array-typed/" itemprop="url">定型数组</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-05T20:16:54+08:00">
                2019-03-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h3 id="什么是定型数组"><a href="#什么是定型数组" class="headerlink" title="什么是定型数组"></a>什么是定型数组</h3><p>JS中数组一直是不限类型的，一个数组中可以同时存在多种不同类型的数据。普通的数组算术运算速度无法满足WebGL的需求，所以es6引入了定型数组。<br>定型数组是用于处理数值类型的(不是所有类型)的专用数组，定型数组<strong>不是</strong>数组类型。</p>
<h3 id="定型数组类型"><a href="#定型数组类型" class="headerlink" title="定型数组类型"></a>定型数组类型</h3><p>不同于普通的数组，定型数组的长度是固定的，创建之后就不能改变。所以定型数组可以在内存中对应一段固定的地址，这就是数组缓冲区。</p>
<h5 id="数组缓冲区"><a href="#数组缓冲区" class="headerlink" title="数组缓冲区"></a>数组缓冲区</h5><p>数组缓冲区是内存中一段字节的地址，可以使用如下方式创建包含<code>10</code>个字节的数组缓冲区。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>)</span><br><span class="line">buffer.byteLength <span class="comment">// 10</span></span><br></pre></td></tr></table></figure></p>
<p>注意传递给<code>ArrayBuffer</code>的是字节而不是byte<br>显然，数组缓冲区的大小是固定的，创建之后就不能修改。可以通过<code>byteLength</code>属性查看缓冲区的大小。<br>还可以通过<code>slice</code>方法在原有的缓冲区上创建新的缓冲区。<br>不能通过数组缓冲区直接修改数据，要修改缓冲区的数据，必须创建视图。</p>
<h5 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h5><p>视图用于操作数组缓冲区，可以基于数组缓冲区创建视图<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer,start,length)</span><br></pre></td></tr></table></figure></p>
<p>其中<code>buffer</code>是数据缓冲区，<code>start</code>和<code>length</code>分别表示视图在视图缓冲区的开始位置和视图的长度。<br>也可以直接传入数值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(<span class="number">10</span>)</span><br></pre></td></tr></table></figure></p>
<p>表示创建<code>10</code>字节大小的视图，通过视图的<code>buffer</code>属性获取视图对应的数据缓冲区</p>
<table>
<thead>
<tr>
<th style="text-align:center">视图属性</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">buffer</td>
<td style="text-align:center">绑定的数组缓冲区</td>
</tr>
<tr>
<td style="text-align:center">byteLength</td>
<td style="text-align:center">视图的长度，单位为字节</td>
</tr>
<tr>
<td style="text-align:center">byteOffset</td>
<td style="text-align:center">视图在缓冲区中的开始位置，默认0，通过new DataView(buffer)创建时传入的第二个参数</td>
</tr>
</tbody>
</table>
<p>可以基于一个数组缓冲区创建多个视图，多个视图都可以修改缓冲区的数据</p>
<p>视图获取和写入数据的方法</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">getInt8(byteOffset,littleEndian)</td>
<td style="text-align:center">获取int8类型的数据</td>
</tr>
<tr>
<td style="text-align:center">setInt8(byteOffset,value,littleEndian)</td>
<td style="text-align:center">写入int8类型的数据</td>
</tr>
</tbody>
</table>
<p><code>byteOffset</code>用于表示从视图的哪个位置读取和写入数据，<code>littleEndian</code>是否按照小端序(不明，不确定与字符的大小端有无关系)<br><code>Int8</code>只是一种类型，所有的8中类型(见下文定型数组类型)都是同样的方法读取和写入数据</p>
<h5 id="定型数组的8种类型"><a href="#定型数组的8种类型" class="headerlink" title="定型数组的8种类型"></a>定型数组的8种类型</h5><p>定型数组包含8中类型<br><code>Int8Array</code>、<code>Uint8Array</code>、<code>Int16Array</code>、<code>Uint16Array</code>、<code>Int32Array</code>、<code>Uint32Array</code>、<code>Float32Array</code>、<code>Float64Array</code>，去掉array后就对应上文中视图读取和写入数字的方法<br>对于<code>Uint8Array</code>还有一种特殊的类型<code>Uint8ClampedArray</code>，区别在于缓冲区的值如果小于0或者大于255，会将其转换到这个范围中</p>
<h3 id="创建定型数组"><a href="#创建定型数组" class="headerlink" title="创建定型数组"></a>创建定型数组</h3><p>从上文可以知道，定型数组其实就是一种固定类型的视图，所以创建方式和视图非常相似。<br>创建定型数组的方式有三种</p>
<ol>
<li>使用数组缓冲区创建<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(buffer, start, length)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>参数与创建视图一样，同样，视图有的三个属性，定型数组都有。如果创建的buffer区域的字节长度不是定型数组基础长度的整数倍，会报错。</p>
<ol start="2">
<li>使用数字创建<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>不同的是，这个<code>10</code>代表的是元素的个数，通过定型数组的<code>length</code>属性可以查看元素的个数。<br>对于不同类型的定型数组，元素个数相同，包含的字节长度不相同。比如都是10个元素的定型数组，<code>Int8Array</code>类型的<code>byteLength</code>只有10,<code>Int16Array</code>类型的<code>byteLength</code>是20。</p>
<ol start="3">
<li>使用数组相关对象创建<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Float32Array</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>类数组对象包括:数组、定型数组、可迭代对象、类数组对象<br>如果相关对象包含不能转换的值，会以0代替。</p>
<h3 id="操作定型数组"><a href="#操作定型数组" class="headerlink" title="操作定型数组"></a>操作定型数组</h3><p>定型数组虽然不是数组，但是和数组非常类似</p>
<p>可以使用<code>arr[0]</code>方式<strong>获取和写入</strong>数据，也可以通过<code>length</code>属性获取定型数组的长度，但是不能修改长度，还可以通过<code>for...of</code>遍历定型数组</p>
<p>数组的方法定型数组基本都支持，除了以下几个方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">concat</span><br><span class="line">push</span><br><span class="line">pop</span><br><span class="line">shift</span><br><span class="line">unshift</span><br><span class="line">splice</span><br></pre></td></tr></table></figure></p>
<p><code>concat</code>不支持是因为不同类型的定型数组合并结果不确定，其它方法则是他们都会改变数组本身的长度，而定型数组的长度是不变的，所以不支持。</p>
<p>定型数组还支持两个额外的方法<code>set</code>和<code>subarray</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(<span class="number">4</span>)</span><br><span class="line">arr.set([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">arr.set([<span class="number">3</span>, <span class="number">4</span>], <span class="number">2</span>)</span><br><span class="line">arr <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></p>
<p><code>set</code>方法将一个数组复制到定型数组，第一个参数是目标数组(或其他类数组对象),第二个参数表示开始复制的位置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Int8Array</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]),</span><br><span class="line">arr2 = arr.subarray(<span class="number">1</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p><code>subarray</code>方法提取已有定型数组的一部分作为一个新的定型数组，两个参数表示开始和结束位置。与<code>slice</code>方法非常类型，区别在于<code>slice</code>方法会创建一个新的<code>buffer</code>，而<code>subarray</code>方法会使用原有的<code>buffer</code>，相当于在原有的<code>buffer</code>上创建一个新的视图。<br>基本等同于一下代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Int8Array</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]),</span><br><span class="line">arr2 = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(arr.buffer, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">//注意此处是2，因为subarray和new Int8Array的第二个参数不同</span></span><br></pre></td></tr></table></figure></p>
<p>区别在于<code>subarray</code>的第二个参数是结束元素位置，而不是新建视图的视图字节长度</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Zhen Huang">
            
              <p class="site-author-name" itemprop="name">Zhen Huang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">博客</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhen Huang</span>
  <div class="powered-by">
    <i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
      本站访客数:<span id="busuanzi_value_site_uv"></span>
    </span>
  </div>
  
</div>



        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
